# 질문

## 스푸핑

### 1. 버스 네트워크에서 스푸핑이 쉬운 이유?

- 모든 노드가 하나의 선을 통해 데이터를 송수신 하기 때문에 누구나 패킷을 감청할 수 있음
  → 감청한 패킷에서 위조된 데이터를 송신할 수도 있음
- 버스 네트워크에는 스위칭이 없는 것 아닌가?
  - 버스 토폴로지는 하나의 물리적 선을 공유하기 때문에 모든 장치가 모든 데이터를 받는다. 즉 스위칭을 써서 특정 노드로만 데이터를 보내는 기능 자체가 없다.
  - 네트워크에 연결되는 순간부터 모든 데이터를 받을 수 있고, 공격자는 스위치 기능을 마비시키거나 속일 필요 없이 네트워크에 몰래 악의적인 노드를 추가하기만 하면 된다.

### 2. 스푸핑 VS 스니핑 VS 스누핑

- 스푸핑: 시스템 권한 탈취해서 정보 훔치기
- 스니핑: 패킷 교환 훔쳐보기
- 스누핑: 네트워크 상에 떠도는 주요 정보를 몰래 획득하는 행위

## www.naver.com 을 주소창에 입력했을 때 일어나는 과정을 설명해보세요

| 대기열, 캐싱, DNS, 라우팅, ARP, 초기연결을 거쳐 컨텐츠를 다운받게 되고, 브라우저렌더링 과정을 거쳐 네이버라는 화면이 나타나게됩니다. 또한 이러한 과정은 비캡슐화, 캡슐화과정을 거쳐 이뤄지게 됩니다.

### 과정

  1. 브라우저는 주소창 입력에 대한 **요청을 대기열**에 넣습니다.
  2. 이전에 동일한 요청에 대해 **캐시에 저장된 데이터**가 있는지 확인합니다.
    캐시된 데이터가 있다면, 네트워크 요청 없이 캐시에서 콘텐츠를 불러올 수 있습니다.
  3. 캐시에 값이 없거나 최신 정보가 필요한 경우, 브라우저는 **DNS 서버**에 “www.naver.com” 의 **IP 주소를 요청**합니다.
  4. IP 패킷을 실제 네트워크 상에서 전송하기 위해, 해당 IP 주소에 해당하는 **물리 주소(MAC) 를 ARP**를 통해 확인합니다.
  5. 브라우저는 대상 **서버와 TCP 3-way handshake 과정을 통해 연결**을 설정합니다.
  7. 연결이 확립되면, 브라우저는 **HTTP GET 요청을 서버로 전송**하여 “www.naver.com” 의 콘텐츠(HTML, CSS, JavaScript 등)를 요청합니다.
  8. 서버는 요청에 대한 응답을 보내며, 이 **데이터들은 다시 캡슐화된 상태**로 네트워크를 통해 전달됩니다.
  9. **브라우저 렌더링 과정**을 걸쳐 최종적으로 사용자의 화면에 “네이버” 웹사이트가 나타나게 됩니다.

### 추가 질문:

#### 캐시의 종류는?

| 프록시 캐시와 브라우저 캐시로 나눠집니다.

- **공유 프록시 캐시**: 서버와 클라이언트 사이에 위치한 중간 캐시 서버가 콘텐츠를 저장해, 여러 클라이언트의 동일 요청에 대해 서버 부담을 줄이고 빠른 응답을 제공하는 방식입니다.
- **브라우저 캐시**: 클라이언트 측에서 웹 브라우저가 다운로드한 모든 문서를 저장해, 재방문 시 서버 요청 없이 로컬 데이터를 활용하여 빠른 화면 렌더링을 지원하는 방식입니다.

#### IP주소를 찾을 때 바로 DNS에 요청하는가?

- 컴퓨터 메모리에 있는 캐시들을 확인한 후에 원하는 정보가 없다면 DNS서버로 요청합니다.

#### 라우팅이란 무엇이며, 라우팅 테이블은 어떻게 동작하나요?

- 라우팅은 네트워크 상에서 데이터 패킷이 출발지에서 목적지까지 도달할 수 있도록 최적의 경로를 결정하고 전달하는 과정입니다. 이 과정에서 가장 중요한 역할을 하는 것이 라우팅 테이블인데, 라우터는 이 테이블을 기반으로 각 패킷의 목적지 IP 주소를 분석하여 어떤 경로로 보내야 할지 결정합니다

#### 브라우저 랜더링 과정에서 어떤 일이 일어나는 지?

- HTML 파일과 CSS 파일을 각각 파싱해 html, body, div, span등 각각의 태그들을 트리화 시킵니다.
- 두 Tree를 결합하여 Rendering Tree를 만들고, Rendering Tree에서 각 노드의 위치와 크기를 계산하여, 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환합니다.
- 마지막으로 레이어를 합성하여 실제 화면에 나타냅니다.

#### 서버에 Get 요청 처리

  1. 네트워크 인터페이스를 통해 클라이언트로부터 도착한 **TCP/IP 패킷을 수신**합니다. 캡슐화된 데이터를 디캡슐화하여 **HTTP GET 요청 메시지를 추출**합니다.
  2. **HTTP 요청을 파싱**하여 HTTP 메소드(GET), 요청 URI, 프로토콜 버전, 그리고 헤더 정보를 확인하여 요청의 세부 사항을 파악합니다
  3. 요청된 URI에 따라, 서버는 해당 리소스를 제공할 수 있는지 판단합니다. (동적 리소스: html 같은 파일 시스템, 정적 리소스: 사용자 요청에 따라 백엔드 서버에서 생성되는 콘텐츠)
  4. 서버는 내부 캐시 또는 CDN 캐시 등을 활용하여, 요청한 리소스가 이미 캐싱되어 있는지 확인합니다.
  5. 요청에 따른 처리 결과를 바탕으로 **HTTP 응답 메시지**(상태 코드 + 필요한 헤더 정보 + 실제 콘텐츠)를 생성합니다.
  6. 생성된 HTTP 응답 메시지는 다시 캡슐화되어 TCP/IP 패킷 형태로 변환됩니다.
  7. 이 패킷은 네트워크를 통해 클라이언트로 전송되며, HTTPS의 경우 **SSL/TLS 암호화 과정**을 거쳐 보안 연결 하에 전송됩니다.
  8. 서버는 처리된 GET 요청과 그에 따른 응답에 대한 정보를 로그 파일에 기록합니다.

## URI, URL, URN 차이점

- URI: 리소스 식별 (URL과 URN을 모두 포함하는 상위 개념)
- URL: 리소스의 위치 명시
  - HTTP, HTTPS, FTP 등과 같이 리소스에 접근하기 위한 구체적인 접근 방법을 제공
- URN: 리소스의 고유한 이름을 지정하는 식별자 -네임스페이스 내에서 리소스를 유일하게 식별하기 위해 사용

### URL에는 쿼리 문자열이 붙을 수 있는데, 서로 다른 쿼리 문자열이 붙은 두 URL은 같은 URL인가?

쿼리 문자열은 URL의 일부로서, 서버에 전달할 추가적인 파라미터나 상태 정보를 담습니다. (스킴(https://)+위치(www.naver.com)+리소스(/index.html))
URL은 전체 문자열로 식별되므로, 쿼리 문자열이 다르면 서로 다른 리소스를 불러오는 것이기 때문에, 서로 다른 URL로 간주됩니다.

```
http://example.com/index.html?user=alice   //<- 두 URL은 기본 경로는 동일하지만, 쿼리 문자열이 다르므로 다른 URL
http://example.com/index.html?user=bob
```

BUT, 만약 단순 sort 쿼리면 결과적으로 같은 리소스이므로 같은 걸로 볼 수 있음

## 라우팅 프로토콜 RIP(벨만포드), OSPF(다익스트라), BGP(경로 벡터 알고리즘)의 차이

### RIP

경로의 ‘hop count(홉 수)’를 기준으로 최적 경로를 결정합니다.
설정이 간단하고 구현이 쉽습니다.

### OSPF

링크의 대역폭, 지연시간 등 다양한 요소를 고려한 ‘비용(cost)’을 사용하여 최적 경로를 계산합니다.
라우팅 정보를 전체 네트워크에 대해 효율적으로 공유하여, 장애 발생 시 신속하게 대처할 수 있습니다

### BGP

단순한 홉 수나 비용보다는 AS 경로, 로컬 프리퍼런스, 멀티-엑스텐션 디멘션(MED) 등 다양한 속성과 정책을 기반으로 최적 경로를 선택합니다.
정책 기반 라우팅이 가능하여 복잡한 인터넷 환경에서 효율적인 경로 선택을 지원합니다.

## HTTP/2.0

### 장점인 멀티플렉싱 각 스트림별 패킷 자체는 지연될 수 있는거 아니냐?

- 멀티플렉싱 자체가 데이터의 신뢰성을 보장하는 것이 아니라, 그 위에 있는 TCP의 신뢰성 메커니즘 덕분에 데이터의 완전성이 유지됩니다.
- 멀티플렉싱에서는 여러 스트림의 프레임이 하나의 TCP 연결에 **인터리브(교차)**되어 전송됩니다.
- 각 스트림의 프레임은 **스트림 식별자**를 가지고 있어서, 수신측에서는 이를 올바른 스트림으로 **재조립**할 수 있습니다.

-> 물론, 네트워크 환경에 따라 특정 스트림의 프레임이 다른 프레임보다 지연될 수 있지만, TCP가 보장하는 신뢰성 때문에 결국 재전송되어 올바른 순서로 도착합니다.

### 스트림이 독립적으로 쪼개서 송수신하여 특정 스트림의 손실이 되었을 때 어떻게 그게 멀쩡한 데이터라고 할 수 있느냐?

- TCP 위에서 동작하기 때문에, 만약 전송 중 어떤 패킷이 손실되면, TCP의 재전송 메커니즘이 작동합니다.
- TCP는 시퀀스 번호와 ACK(확인 응답)를 통해 데이터의 손실을 감지하고, 손실된 패킷을 재전송함으로써 모든 데이터가 올바르게 도착하도록 보장합니다.
- 스트림이 여러 프레임으로 분할되어 전송되더라도, 특정 스트림의 프레임이 일시적으로 손실되더라도 TCP가 이를 보완하여 최종적으로는 모든 스트림의 데이터가 완전하게 복원됩니다.
