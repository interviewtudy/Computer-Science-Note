#### 용어 정리

| 라이브러리

- 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것을 의미
- 폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유롭다.

| 프레임워크

- 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것을 의미
- 폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격하다.

---

# 디자인 패턴

프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 ‘규약’형태로 만들어 놓은 것

---

## 싱글톤 패턴

| 하나의 클래스, 하나의 인스턴스!

하나의 클래스에 여러 개의 개별적인 인스턴스를 만들 수 있지만, 그렇게 하지 않고 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는 데 쓰임

장점 : 하나의 인스턴스를 다른 모듈들이 공유하며 사용 -> 인스턴스를 생성할 때 드는 비용이 줄어듬
단점 : 높은 의존성

< 사용 예시 >

```
// DB 연결 모듈 -> 장점: DB 연결에 관한 인스턴스 생성 비용을 아낄 수 있다.

const URL = 'mongodb://localhost:27017/kundolapp'
cosnt createConnnection = url => ({"url" : url})

class DB {
	constructor(url){
		if (!DB.instance)
			DB.instance = createConnection(url)
		return DB.instance
	}
	connect(){
		return this.instance
	}
}

const a = new DB(URL)
const b = new DB(URL)
console.log(a === b) //true
```

메인 모듈에서 데이터베이스 연결에 관한 인스턴스를 정의하고 다른 모듈 A 또는 B에서 해당 인스턴스를 기반으로 쿼리를 보내는 형식으로 사용

```
	const mysql = require('mysql');
	const pool = mysql.createPool({
		connectionLimit: 10,
		host: 'example.org',
		user: 'kundol',
		password: 'secret',
		database: '승철이디비'
	});
	pool.connect();

	// 모듈 A
	pool.query({
		if(error)
			throw error;
			console.log('The solution is: ', results[0].solution);
	});

	// 모듈 B
	pool.query({
		if(error)
			throw error;
			console.log('The solution is: ', results[0].solution);
	});

```

### 싱글톤 패턴의 단점

TDD 적용 어려움 :
TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 한다.

BUT, 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 ‘**독립적인**’인스턴스를 만들기 어려움

### 의존성 주입

싱글톤 패턴의 단점인 모듈 간의 높은 결합도 문제를 *의존성 주입(Dependency Injection)*을 통해 모듈간의 결합을 조금 더 느슨하게 만들어 해결할 수 있다.

\*_의존성이란_ : 종속성이라고도 하며 A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A또한 변해야 된다는 것을 의미

메인 모듈이 ‘직접’ 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자가 이 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식

이를 통해 메인 모듈은 하위 모듈에 대한 의존성이 떨어지게 됩니다. 참고로 이를 ‘디커플링이 된다’라고 함

**장점** :

1. 모듈을 쉽게 교체할 수 있는 구조가 됨 -> 쉬운 테스팅과 수월한 마이그레이션 가능
2. 구현 시 추상화 레이어를 도입하고, 그 위에 구현체를 추가
   -> 애플리케이션 의존성 방향이 일관됨, 애플리케이션을 쉽게 추론 가능, 모듈 간의 관계들이 조금 더 명확해짐

**단점** :

1. 모듈 분리로 클래스 수가 증가하여 복잡성이 커지고, 약간의 런타임 패널티가 발생할 수 있음

#### 의존성 주입 원칙

1. 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함
2. 상위 하위 모듈 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 함

라는 의존성 주입 원칙을 지켜주면서 만들어야 한다.

**Enum**
상수의 집합을 정의할 때 사용되는 타입이다. Enum을 기반으로 상수 집합을 관리한다면 코드를 리팩토링할 때 상수 집합에 대한 로직 수정 시 이 부분만 수정하면 된다는 장점이 있고, 본질적으로 스레드세이프하기 떄문에 싱글톤 패턴을 만들 때 도움이 된다

---

## 팩토리 패턴

| 상위 클래스는 뼈대, 하위 클래스 상세 구현!

객체를 사용하는 코드에서 **객체 생성 부분을 떠어내 추상화한 패턴**이자 상속 관계에 있는 두 클래스에서 **상위 클래스가 중요한 뼈대를 결정**하고, **하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정**하는 패턴

상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖게 됩니다. 그리고 객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩토링하더라도 한 곳만 고칠 수 있게 되니 유지 보수성이 증가됩니다.

예를 들어 라떼 레시피와 아메리카노 레시피, 우유 레시피라는 구체적인 내용이 들어 있는 하위 클래스가 컨테이너 벨트를 통해 전달되고, 상위 클래스인 바리스타 공장에서 이 레시피들을 토대로 우유등을 생산하는 생산 공정을 생각

---

## 전략 패턴

| 객체의 행위에 따라 전략을 컨텍스트 안에 교체

객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 캡슐화한 알고리즘을 _컨텍스트_ 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

\*_컨텍스트_ : 프로그래밍에서 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 말한다.

### passport 전략 패턴

passport는 node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로, 여러 가지 전략을 기반으로 인증할 수 있게 합니다. 서비스 내의 회원가입된 아이디와 비밀번호를 기반으로 인증하는 LocalStrategy 전략과 페이스북, 네이버 등 다른 서비스를 기반으로 인증하는 OAuth 전략 등을 지원합니다.

---

## 옵저버 패턴

| 객체의 변화를 옵저버들에게 전달!

*주체*가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴

_여기서 주체: _ 객체의 상태 변화를 보고 있는 관찰자
_옵저버_ 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 상항’이 생기는 객체들

- 주체와 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축하기도 함

옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC 패턴에도 사용됨
ex) 주체라고 볼 수 있는 모델에서 변경 사항이 생겨 update() 메서드로 옵저버인 뷰에 알려주고 이를 기반으로 컨트롤러 등이 작동하는 것

Jd에서 옵저버 패턴은 프록시 객체를 통해 구현할 수도 있다.

**프록시 객체**
대상의 기본 동작을 가로채 특정 속성 접근 시 로직을 강제할 수 있는 객체

JS에서 프록시 객체는 두 개의 매개변수를 가진다

- target: 프록시 할 대상, handler: target 동작을 가로채고 어떠한 동작을 할 것인지가 설정되어 있는 함수

---

## 프록시 패턴과 프록시 서버

대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴

이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용

이는 앞서 설명한 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용됩니다.

**프록시 서버에서의 캐싱**

캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청ㅇ에 대해 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용한느 것을 말한다. 이를 통해 불필요하게 외부와 연결하지 않기 때문에 트랙픽을 줄일 수 있다는 장점이 있다.

#### 프록시 서버

서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킵니다.

#### 프록시 서버로 쓰는 nginx

nginx는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서ㅂ이며, 주로 node.js 서버 앞단의 프록시 서버로 활용

node.js의 창시자는

node.js의 _버퍼 오버플로우_ 취약점을 예방하기 위해서는 nginx를 프록시 서버로 앞단에 놓고 node.js를 뒤쪽에 놓는 것이 좋다라고 함

이를 통해 익명 사용자가 직접적으로 서버에 접근하는 것을 차단하고, 간접적으로 한 단계를 더 거치게 만들어서 보안을 강화할 수 있습ㄴ다.

nginx를 프록시 서버로 둬서 실제 포트를 숨길 수 있고 장적 자원을 *gzip 압축*하거나, 메인 서버 앞단에서의 로깅을 할 수도 있습니다.

_버퍼 오버플로우_:
버퍼는 보통 데이터가 저장되는 메모리 공간으로 , 메모리 공간을 벗어나는 경우를 말한다. 이때 사용되지 않아야 할 영역에 데이터가 덮어씌워져 주소, 값을 바꾸는 공격이 발생하기도 한다.

_gzip 압축_
LZ77과 Huffman 코딩의 조합인 deflate알고리즘을 기반으로 한 압축 기술이다. gzip 압축을 하면 데이터 전송량을 줄일 수 있지만, 압축을 해제했을 때 서버에서 CPU 오버헤드도 생각해서 gzip 압축 사용 유무를 결정해야한다.

**프록시 서버로 쓰는 CloudFlare**

CloudFlare는 전 세계적으로 분산된 서버가 있고 이를 통해 어떤한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 *CDN *서비스입니다.

cloudFalre는 웹 서버 앞단에 프록시 서버로 두어 DDOS 공격 방어나 HTTPS 구축에 쓰입니다.

또한, 서비스를 배포한 이후에 해외에서 무언가 의심스러운 트래픽이 많이 발생하면 이 때문에 많은 클라우드 서비스 비용이 발생할 수도 있는데, 이떄 cloudFlare가 의심스러운 트래픽인지 먼저 판단해 CaptCha등을 기반으로 이를 일정 부분 막아주는 역할도 수행합니다.

앞으로 그림처럼 사용자, 크롤러, 공격자가 자신의 웹 사이트에 접속하게 될 텐데, 이때 cloudFlare를 통해 공격자로부터 보호할 수 있습니다.

**DDOS 공격 방어**
DDOS는 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형 CloudFlare는 의심스러운 트래픽, 특히 사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동으로 차단해서 DDOS 공격으로부터 보호합ㄴ디ㅏ. CloudFlare의 거대한 네트워크 용량과 캐싱 전략으로 소규모 DDOS 공격은 쉽게 막아낼 수 있으며 이러한 공격에 대한 방화벽 대시보드도 제공합니다

_HTTPS 구축_
서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축할 수도 있습니다. 하지만 CloudFlare를 사용하면 별도의 인증서 설치 없이 좀 더 손쉽게 HTTPS를 구축할 수 있다.

_CDN_:
각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말한다. 이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄일 수 있다.

CORS와 프론트엔드의 프록시 서버
CORS는 서버가 웹 브라운저에서 리소스를 로드할 때 다른 *오리진*을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘입니다.

프론트엔드 개발 시 프론트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CORS에러를 마주치는 데, 이를 해결하기 위해 프론트앤드에서 프록시 서버를 만들기도 합니다

_오리진_: 프로토콜과 호스트이름, 포트의 조합을 말한다.

포트번호가 다를 시 CORS에러가 남
그럴 때 프록시 서버를 둬서 프론트엔드 서버에서 요청되는 오리진을 바꾸는 것

---

## 이터레이터 패턴

이터레이터 패턴은 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴입니다,
이를 통해 순회할 수 있는 여러 가지 자료형의 구조와는 상관없이 이터레이터하는 하나의 인터페이스로 순회 가능합니다.

---

## 노출모듈 패턴

즉시 실행 함수를 통해 접근 제어자를 만드는 패턴을 말합니다.
접근 제어가 존재 하지 않는 경우 노출모듈 패턴을 통해 접근 제어자를 구현하기도 함

---

## MVC 패턴

Model, View, Controller로 이루어진 디자인 패턴

애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있습니다. 재사용성과 확장성이 용이하다는 장점이 있고, 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있습니다.
ex) 스프링

**모델**
애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻합니다

예를 들어 사각형 모양의 박스 안에 글자가 들어 있다면 그 사각형 모양의 박스 위치 정보, 글자 내용, 글자 위치, 글자 포맷에 관한 정보를 모두 가지고 있어야 합니다. 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신합니다

**뷰**
사용자 인터페이스 요소를 나타냅니다. 즉 모델을 기반으로 사용자 볼 수 있는 화면을 뜻합니다. 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며 단순히 사각형 모양 등 화며에 표시되는 정보만 깆고 있어야 합니다.

또한, 변경이 일어나면 컨트롤러에 이를 전달해야 합니다.

**컨트롤러**
하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당합ㄴ디ㅏ, 또한, 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성요소에 해당 내용에 대해 알려줍니다.

---

## MVP 패턴

MVC패턴으로부터 파생되었으며 컨트롤러 대신 프레젠터로 교체된 패턴
뷰와 프레젠터는 일대일 관계이기 떄문에 MVC패턴보다 더 강한 결합을 지닌 디자인 패턴이라고 봄

---

## MVVM패턴

컨트롤러 대신 뷰모델로 바뀐 팬턴

뷰모델은 뷰를 추상화한 계층이며, MVVM 패턴은 MVC 패턴과는 다르게 *커맨드*와 *데이터 바인딩*을 가지는 것이 특징입니다, 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있습니다.

_커맨드_ : 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
_데이터 바인딩_ : 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법, 뷰모델을 변경하면 뷰가 변경됨

ex) Vue.js

---

---

# 프로그래밍 패러다임

프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론

## 선언형과 함수형 프로그래밍

선언형은 무엇을 풀어내는가에 집중하는 패러다임이며, 프로그램은 함수로 이루어진 것이라는 명제가 담겨 있는 패러다임이기도 합니다. 함수형 프로그래밍은 선언형 패러다임의 일종

함수형 프로그래밍 작은 순수 함수들을 블록처럼 쌓아 로직을 구현하고 고차 함수를 통해 재사용성을 높인 프로그래밍 패러다임입니다.

_순수 함수_ : 출력이 입력에만 의존하는 것
_고차함수_ : 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것을 말함

- 고차 함수를 쓰기 위해서는 해당 언어가 일급 객체라는 특징을 가져야 하며 그 특징은 다음과 같음

_일급 객체_

- 변수나 메서드에 함수를 할당할 수 있습니다.
- 함수 안에 함수를 매개변수로 담을 수 있습니다
- 함수가 함수를 반환할 수 있습니다

함수형 프로그래밍은 이외에도 커링, 불변성 등 많은 특징이 있습니다.

## 객체지향 프로그래밍

객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 개체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 망합니다.
설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다이멩 비해 상대적으로 느립니다.

_객체 지향 프로그래밍 특징_: 추상화, 캡슐화, 상속성, 다향성

_추상화_ : 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것을 의미
_캡슐화_ : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것

_상속성_ : 상위 클래스의 특성을 하위 클래스가 이어받ㅇ차서 재사용하거나 투가 확장하는 것을 말함
코드의 재사용 츣면, 계층ㄹ적인 관계 생성, 유지 보수성 특면에서 증요

_다향성_ : 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것  
ex) 오버라이딩(상속 받은 메서드를 재정의), 오버로딩(같은 이름의 매서드를 두는 것)

### 설계 원칙 SOLID

S. 단일 책임 원칙 : 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙
O. 개발 폐쇄 원팃 : 유지 보수 사항이 생기면 코드를 쉽게 확장할 수 있도록 함, 수정에는 닫혀야함
L. 리스코프 치환 원칙 : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어햐 하는 것
I. 인터페이스 분리 : 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙
D. 의존 역전 원칙 : 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향을 받지 않게 하는 원칙

## 절차형 프로그래밍

로직이 수행되어햐 할 연속적인 계산 과정으로 이루어져 있음

일이 진행되는 방식으로 그저 코드를 구혀하기만 하면 되기 떄무에 코드의 가독성이 좋으며 실행 속도가 빠릅니다. 그렇기 떄무에 계선이 많은 작업 등에 쓰임
