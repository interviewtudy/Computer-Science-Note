# 디자인 패턴

디자인 패턴은 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 규악 상태로 만들어 놓은 것을 말함

## 싱글톤 패턴

싱글톤 패턴이란 하나의 클래스에 하나의 인스턴스만 가지는 패턴을 의미함

- 데이터베이스 연결 모듈에 많이 사용 (ex.mongoose 의 connect 함수, Node.js 에서 MySQL 연결 시) -> 인스턴스 생성 비용을 감소시킬 수 있음
- 자바스크립트에서는 리터럴 {} 또는 `new Object`로 객체를 생성하는 것만으로도 싱글톤 패턴 구현 가능
- 자바에서는 주로 중첩 클래스를 이용해서 싱글톤 패턴을 구현

### 장점

- 인스턴스 생성 비용 감소
- 전역적인 접근 보장

### 단점

- TDD(Test Driven Development) 시 문제 발생<br/>
  단위 테스트 시 어떤 순서로도 실행할 수 있어야 하기 때문에 테스트가 서로 독립적이어야 함. 하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하므로 테스트별로 독립적인 인스턴스를 만들기 어려움
- 모듈 간의 결합을 강하게 만들 수 있음<br/>
  주로 의존성 주입을 통해 모듈 간 결합을 약하게 만들어 문제를 해결함

## 의존성 주입

메인 모듈이 하위 모듈에 의존성을 직접 주지 않고 의존성 주입자를 통해 간접적으로 의존성을 주입하도록 하는 방식

- 상위 모듈이 하위 모듈에서 어떤 것도 가져오지 말아야 함
- 두 모듈 다 추상화에 의존해야 하고 추상화는 세부 사항에 의존하지 말아야 함<br/>

  ```dart
  // 구체 클래스(Concrete class) 에 의존할 때
  class Caffeine() {
    String getCoffee() => "커피";

    String getEnergyDrink() => "에너지 음료";
  }

  class Developer {
    final caffeine = Caffeine()

    String getCoffee() {
      return caffeine.getCoffee()
    }

    String getEnergyDrink() {
      return caffeine.getEnergyDrink()
    }
  }

  // 추상화에 의존할 때
  abstract class Caffeine {
    String getName();
  }

  class Coffee implements Caffeine {
    @override
    String getName() => "커피";
  }

  class EnergyDrink implements Caffeine {
    @override
    String getName() => "에너지 드링크";
  }

  class Developer {
    final Caffeine caffeine

    Developer({required this.caffeine})
  }

  void main() {
    final developer1 = Developer(caffeine: Coffee())
    final developer2 = Developer(caffeine: EnergyDrink())

    print(developer1.getName())
    print(developer2.getName())
  }
  ```

  여기서 테스트를 위한 MockDrink 라는 객체를 추가하고 싶을 때, 구체 클래스를 사용한 경우는 Developer 에도 getMockDrink() 를 추가해줘야 하지만 추상 클래스를 사용한 경우엔 Developer 는 전혀 수정하지 않고 MockDrink 클래스만 정의해주면 됨(즉 의존성 주입이 잘 된 케이스)

### 장점

- 모듈을 쉽게 교체할 수 있음 -> 테스팅, 마이그레이션에 용이
- 의존성 방향이 일관됨(싱글톤클래스 -> 다른객체 단방향으로 일관적) -> 객체간의 관계와 흐름 파악 쉬워짐

### 단점

- 모듈이 많이 분리되면서 클래스 수 증가 -> 복잡성 증가
- 약간의 런타임 패널티가 생기기도 함

## 팩토리 패턴(Factory Pattern)

팩토리 패턴이란 객체를 사용하는 코드에서 객체 생성 부분을 분리해 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 뼈대를 결정하고 하위 클래스에서 생성에 관한 구체적인 내용을 결정하는 패턴을 의미함

```dart
class DeveloperFactory {
  final String type
  DeveloperFactory({required this.type})

  String getCaffeine(String type) {
    if (type == "Coffee") return Coffee();
    elif (type == "EnergyDrink") return EnergyDrink();
  }
}
```

- 상위 클래스와 하위 클래스가 분리됨 -> 느슨한 결합을 가져 더 많은 유연성을 가짐 -> 리팩토링 시 한 곳만 고칠 수 있어 유지보수성 증가

## 전략 패턴(Strategy Pattern)

전략 패턴이란 객체의 행위를 바꾸고 싶을 때 직접 수정하지 않고 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하도록 하는 패턴을 의미함<br/>
이때 이 캡슐화한 알고리즘을 전략이라고 부름

```dart
abstract class PlayStrategy {
  String play();
}

class PianoPlayStrategy implements PlayStrategy {
  final String pianoName;

  PianoPlayStrategy({required this.pianoName});

  @override
  String play() {
    return "${pianoName}을 연주하는 중";
  }
}

class GuitarPlayStrategy implements PlayStrategy {
  final String guitarType;
  final int lineNum;

  GuitarPlayStrategy({required this.guitarType, required this.lineNum});

  @override
  String play() {
    return "${guitarType}은 ${lineNum}개의 줄로 소리가 나요";
  }
}

class Stage {
  void play(PlayStrategy playType) {
    final play = playType.play();
    print(play);
  }
}

void main() {
  final stage = Stage();
  stage.play(PianoPlayStrategy(pianoName: "그랜드 피아노"));
  stage.play(GuitarPlayStrategy(guitarType: "베이스 기타", lineNum: 4));
}
```

## 옵저버 패턴(Observer Pattern)

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴을 의미함<br>

- 주체는 상태 변화를 보고 있는 관찰자, 옵저버는 추가 변화 사항이 생기는 객체를 의미
- 객체와 주체는 분리될 수도 있고, 합쳐져 있을 수도 있음
- 이벤트 기반 시스템에 사용하며 MVC 패턴에도 사용됨(객체: 모델, 주체: 컨트롤러, 옵저버: 뷰)
- 자바스크립트에서는 프록시 객체를 통해 구현할 수도 있음

## 자바의 상속과 구현

### 상속(extends)

- 자식 클래스가 부모 클래스의 메서드 등을 상속 받아 사용함
- 자식 클래스에서 추가 및 확장 가능 -> 재사용성, 중복성의 최소화

### 구현(implements)

- 부모 인터페이스(interface)를 자식에서 재정의하여 구현
- 상속과 달리 부모 클래스의 메서드를 반드시 재정의해 구현해야 함
- 상속은 일반클래스, abstract 클래스를 기반으로 구현하고 구현은 인터페이스를 기반으로 구현함

## 프록시 객체

어떤 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 의미함

- 자바스크립트에서는 target(프록시할 대상), handler(target 동작을 가로채고 어떤 동작을 할 것인지 설정되어 있는 함수)를 매개변수로 가짐
- Vue.js 3.0 에서는 프록시 객체를 이용한 옵저버 패턴으로 구현한 부분이 있음<br/>ref 나 reactive 로 정의하면 해당 값이 바뀔 때 자동으로 DOM 에 있는 값을 변경함

## 프록시 패턴(Proxy Pattern)과 프록시 서버

프록시 패턴은 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 패턴을 의미함

- 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용
- 프록시 서버로도 활용됨

### 프록시 서버

프록시 서버란 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킴

- nginx 는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹서버로 Node.js 서버 앞단의 프록시 서버로 활용함
- Node.js 의 버퍼 오버플로우 취약점을 에방하기 위해서 nginx 를 프록시 서버로 사용할 것을 권장<br/>
  - 익명 사용자가 직접적으로 서버에 접근하는 것을 차단 -> 보안 강화
  - 실제 포트를 숨길 수 있음
  - 정적 자원을 gzip 압축할 수 있음
  - 메인 서버 앞단에서의 로깅이 가능함
- CloudFlare 는 전 세계적으로 분산된 서버가 있고, 어떤 시스템의 콘텐츠 전달을 빠르게할 수 있는 CDN(Content Delivery Network) 서비스
  - 거대한 네트워크 용량과 캐싱 전략을 통해 의심스러운 트래픽, 사용자가 아닌 시스템을 통해 오는 트래픽을 자동으로 차단 가능 -> 소규모 DDOS 공격 방어 용으로 사용할 수 있음
  - 별도의 인증서 설치 없이 손쉽게 HTTPS 를 구축할 수 있도록 도와줌
- CORS(Cross-Origin Resource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게하는 HTTP 헤더 기반 메커니즘으로 프론트가 백엔드 서버와 통신할 때 CORS 에러를 마주하는 문제를 해결하기 위해 프록시 서버를 도입하기도 함

## 이터레이터 패턴(Iterator Pattern)

이터레이터 패턴은 이터레이터(iterator)를 사용해 컬렉션의 요소에 접근하는 디자인 패턴을 의미함<br/>
순회할 수 있는 여러 가지의 자료형의 구조와 상관 없이 이터레이터라는 하나의 인터페이스를 통해 순회가 가능함

## 노출모듈 패턴

노출모듈 패턴(Revealing Module Pattern)은 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 의미함

- 자바스크립트는 private, public 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행되기 때문에 이 패턴을 사용하여 접근 제어자를 구현하기도 함
- 자바스크립트의 CJS(CommonJS) 모듈 방식이 노출모듈 패턴을 기반으로 만들어졌음

## MVC 패턴

MVC 패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴을 의미함

- 모델: 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함. 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신함
- 뷰: 사용자 인터페이스 요소. 모델이 가지고 있는 정보를 따로 저장하지 않아야 하고 변경이 일어나면 컨트롤러에 이를 전달 해야함
- 컨트롤러: 하나 이상의 모델과 하나이상의 뷰를 잇는 다리 역할을 하며 이벤트와 같은 메인 로직을 담당. 모델과 뷰의 생명주기를 관리하고, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줌
- 자바 플랫폼을 위한 오픈 소스 프레임워크, 스프링(Spring) 이 대표적인 MVC 패턴을 이용하는 프레임워크

### 장점

- 애플리케이션 구성 요소를 세 가지로 구분해 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있음
- 재사용성과 확장성이 용이함

### 단점

- 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐

## MVP 패턴

MVP 패턴은 MVC 패턴으로부터 파생되어 MVC 의 C 가 프레젠터(Presenter)의 P로 교체된 패턴을 의미함<br/>

- 뷰와 프레젠터는 일대일 관계로 MVC 패턴보다 더 강한 결합을 지님
- 반응형(reactivity)이 특징인 프론트엔드 프레임워크, Vue.js 가 MVVM 패턴을 가진 대표적인 프레임워크

## MVVM 패턴

MVVM 패턴은 MVC의 C가 뷰모델(View Model)의 VM 으로 교체된 패턴을 의미함<br/>

- 뷰모델은 뷰를 더 추상화한 계층으로 MVC 패턴과 달리 커맨드와 데이터 바인딩을 가짐
- 뷰와 뷰모델 사이 양방향 데이터 바인딩을 지원함

### 장점

- UI 를 별도의 코드 수정 없이 재사용할 수 있음
- 단위 테스팅하기 쉬움

<br/><br/>

# 프로그래밍 패러다임

프로그래밍 패러다임(Programming Paradigm)이란 프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론

- jdk 1.8 이전의 자바가 객체지향 프로그래밍을 지원하는 것처럼 어떤 언어는 특정 패러다임을 지원하기도 함(jdk 1.8 이후로는 함수형 프로그래밍 패러다임 지원을 위해 람다식, 생성자 레퍼런스, 메서드 레퍼런스를 도입하고 선언형 프로그래밍을 위해 스트림 같은 표준 API 등도 추가함)
- 여러 패러다임을 지원 하는 언어: C++, 파이썬, 자바스크립트
- 프로그래밍 패러다임은 크게 선언형과 명령형으로 나뉘고, 선언형은 함수형, 명령형은 객체지향과 절차지향으로 나뉨

## 선언형과 함수형 프로그래밍

- 선언형 프로그래밍(Declarative Programming)이란 '무엇을' 풀어내는가에 집중하는 패러다임으로, '프로그램은 함수로 이루어진 것이다' 라는 명제가 담겨있는 패러다임이기도 함<br/>
- 함수형 프로그래밍(Functional Programming)이란 선언형 프로그래밍의 일종으로, 작은 순수 함수들을 블록처럼 쌓아 로직을 구현하고 고차 함수를 통해 재사용성을 높인 프로그래밍 패러다임임
- 자바스크립트는 단순하고 유연한 언어이자, 함수가 일급 객체이기 때문에 객체지향 프로그래밍보다는 함수형 프로그래밍 방식이 더 선호됨
- 순수함수: 출력이 입력에만 의존하는 함수
- 고차함수: 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 함수
- 일급객체: 다음 특징을 가지고 있는 객체
  - 변수나 메서드에 함수를 할당할 수 있음
  - 함수 안에 함수를 매개변수로 담을 수 있음
  - 함수가 함수를 반환할 수 있음
- 커링, 불변성 등의 특징을 가짐

## 객체지향 프로그래밍

- 객체지향 프로그래밍(OOP, Object-Oriented Programming)이란 객체들의 집합으로 프로그래밍의 상호 작용을 표현하며 데이터를 객체로 취급해 객체 내부에 선언된 메서드를 활용하는 방식을 의미함
- 설계에 많은 시간이 소요됨. 처리 속도가 상대적으로 느림

### 객체지향 프로그래밍 특징

- 추상화: 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것
- 캡슐화: 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것
- 상속성: 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것
- 다형성: 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것.(ex. 오버로딩, 오버라이딩)
  - 오버로딩: 같은 이름을 가진 메서드를 여러개 두는 것
  - 오버라이딩: 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것

### 설계 원칙

객체지향 프로그래밍을 설계할 때는 SOLID 원칙을 지켜야 함

1. S - 단일 책임 원칙(SRP, Single Responsibility Principle): 모든 클래스는 각각 하나의 책임만 가져야 함
2. O - 개방-폐쇄 원칙(OCP, Open Closed Principle): 유지 보수 시, 기존의 코드를 잘 변경하지 않으면서도 쉽게 확장할 수 있어야 함
3. L - 리스코프 치환 원칙(LSP, Liskov Substitution Principle): 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서도 하위 타입의 인스턴스로 바꿀 수 있어야 함(부모 객체에 자식 객체를 넣어도 시스템이 정상 동작해야 함)
4. I - 인터페이스 분리 원칙(ISP, Interface Segregation Principle): 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 함
5. D - 의존 역전 원칙(DIP, Dependency Inversion Principle): 자신 보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 해야 함(상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 함)

## 절차형 프로그래밍

절차형 프로그래밍은 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있음

- 장점: 일이 진행되는 방식으로 코드를 구현하기만 하면 됨 -> 코드 가독성이 좋고 실행 속도가 빠름
- 단점: 모듈화하기 어렵고 유지 보수성이 떨어짐

## 패러다임의 혼합

- 가장 좋은 패러다임은 없음. 비즈니스 로직과 서비스 특징을 고려해 패러다임을 정하는 것이 좋음
- 하나의 패러다임을 기반으로 통합하여 서비스를 구축할 수도 있지만 적절하게 조합하여 상황과 맥락에 따라 각 패러다임의 장점만 살려 개발하는것이 베스트

<br/><br/>

# 용어

- 컨텍스트: 상황, 맥락, 문맥을 의미하며 개발자가 어떤 작업을 완료하는데 필요한 모든 관련 정보를 말함
- DOM(Document Object Model): 문서 객체 모델. 웨 ㅂ브라우저상의 화면을 이루고 있는 요소들을 지칭함
- 프록시 서버에서의 캐싱: 캐시 안에 정보를 담아두고 캐시 안 정보를 요구하는 요청에 대해서는 원격 서버가 아닌 캐시 안에 데이터를 활용하는 것(트래픽 감소시킬 수 있음)
- 버퍼 오버플로우: 버퍼는 보통 데이터가 저장되는 메모리 공간으로, 메모리 공간을 벗어나는 경우를 말함. 사용되지 않아야할 영역에 데이터가 덮어씌워져 주소, 값을 바꾸는 공격이 발생하기도 함
- gzip 압축: LZ77과 Huffman 코딩의 조합인 DEFLATE 알고리즘을 기반으로 한 압축 기술을 말함. gzip 압축 시 데이터 전송량을 줄일 수 있지만 압축 해제 시 서버에서의 CPU 오버헤드도 생각해서 사용 유무를 결정해야 함
- CDN(COntent Delivery Network): 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말함. 이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄일 수 있음
- 오리진: 프로토콜과 호스트 이름, 포트의 조합을 말함.
- 이터레이터 프토로콜: 이터러블한 객체들을 순회할 때 쓰이는 규칙
- 이터러블한 객체: 반복 가능한 객체로 배열을 일반화한 객체
- public: 클래스에 정의된 함수, 자식 클래스, 외부 클래스에서 접근 가능
- protected: 클래스에 정의된 함수, 자식클래스에서 접근 가능, 외부 클래스에서 접근 불가능
- private: 클래스에 정의된 함수에서 접근 가능, 자식 클래스, 외부 클래스에서 접근 불가능
- 즉시 실행 함수: 함수를 정의하자마자 바로 호출하는 함수. 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용함
- 커맨드: 여러가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
- 데이터 바인딩: 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경됨
