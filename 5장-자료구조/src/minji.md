# 복잡도

## 시간 복잡도

시간 복잡도란 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계를 가리킴. 어떤 알고리즘 로직이 얼마나 오랜 시간이 걸리는지를 나타내는데 사용

- 효율적인 코드로 개선하는 데 쓰이는 척도로 사용

### 빅오 표기법

입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지를 나타냄

- 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없애서 표기함.

## 공간 복잡도

공간 복잡도란 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양을 의미함

- 정적 변수로 선언된 것 말고도 동적으로 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함

## 자료 구조에서의 시간 복잡도

- 평균/최악의 시간 복잡도를 고려해서 사용함

<br/><br/><br/><br/>

# 선형 자료 구조

선형 자료 구조란 요소가 일렬로 나열되어 있는 자료 구조를 의미함

## 연결 리스트

데이터를 감싼 노드를 포인터로 연결해서 공간의 효율성을 극대화시킨 자료구조

- 시간 복잡도: 삽입&삭제 - O(1) / 탐색 - O(n)
- 종류
  - 싱글 연결 리스트: next 포인터만 가짐
  - 이중 연결 리스트: prev, next 포인터를 가짐
  - 원형 이중 연결 리스트: 이중 연결 리스트와 같은 형태지만 마지막 노드의 next 가 헤드 노드를 가리킴

## 배열(Array)

배열이란 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터들을 모아놓은 집합을 의미함

- 시간 복잡도: 탐색 - O(1) / 삽입&삭제 - O(n)
- 해당 원소에 빠르게 접근해야 하거나 간단하게 데이터를 쌓고 싶을 때 사용

### 랜덤 접근과 순차적 접근

랜덤 접근이란 배열같은 순차적인 데이터에서 임의의 인덱스애 해당하는 데이터에 접근할 수 있는 기능을 말함

### 배열 vs 연결 리스트

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>배열</th>
      <th>연결 리스트</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>랜덤 접근 가능 여부</td>
      <td>가능</td>
      <td>불가능</td>
    </tr>
    <tr>
      <td>탐색 속도</td>
      <td>빠름</td>
      <td>느림</td>
    </tr>
    <tr>
      <td>데이터 추가 및 삭제</td>
      <td>느림</td>
      <td>빠름</td>
    </tr>
  </tbody>
</table>

## 벡터(Vector)

동적으로 요소를 할당할 수 있는 동적 배열

- 컴파일 시점에 개수를 모른다면 사용
- 중복 허용, 순서 존재, 랜덤 접근 가능
- 시간 복잡도: 탐색 - O(1) / 맨 뒤 또는 맨 앞 삽입&삭제 - O(1) / 기타 삽입&삭제 - O(n)
- `push_back()` 의 경우 O(1) 이 소요되는데, 벡터의 크기가 증가하는 시간 복잡도가 amortized 복잡도, 즉 상수 시간 복잡도 O(1) 과 유사한 시간 복잡도를 가짐

## 스택

가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO)을 가진 자료구조

- 재귀적인 함수, 알고리즘, 웹 브라우저 방문 기록 등에 사용
- 시간복잡도: 삽입&삭제 - O(1) / 탐색 - O(n)

## 큐

먼저 집어 넣은 데이터가 먼저 나오는 성질(FIFO)을 지닌 자료구조

- CPU 작업을 기다리는 프로세스, 스레드 행렬, 네트워크 접속을 기다리는 행렬, 너비 우선 탑색, 캐시 등에 사용
- 시간 복잡도: 삽입&삭제 - O(1) / 탐색 - O(n)

# 비선형 자료구조

비선형 자료구조란 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 의미함. 일반적으로 트리나 그래프를 말함

## 그래프

그래프는 정점과 간선으로 이루어진 자료구조를 의미함

### 정점과 간선

A에서 B로 간다고 했을 때 A,B 는 정점, A에서 B로 가는 길을 간선이라고 함

- A->B 와 B->A 가 모두 가능하면 양방향 간선, A->B 만 가능하면 단방향 간선이라고 함
- 정점으로 나가는 간선을 해당 정점의 outdegree, 들어오는 간선을 indegree 라고 함.
- 가중치: 간선과 정점 사이에 드는 비용

## 트리

정점과 간선으로 이루어져 있고 트리 구조로 배열된 일종의 계층적 데이터 집합을 말함

- 숲: 트리로 구성된 집합

### 트리의 특징

- 루트 노드, 내부 노드, 리프 노드 등으로 구성
- 부모, 자식 계층 구조를 가짐. 같은 경로 상에서 어떤 노드보다 위에 있으면 부모, 아래에 있으면 자식이라고 함
- V - 1 = E(간선수는 노드수 -1)
- 임의의 두 노드 사이 경로는 유일무이하게 존재하고 어떤 노드와 어떤 노드까지의 경로가 반드시 존재함

### 트리의 구성

- 루트노드: 가장 위에 있는 노드
- 내부노드: 루트 노드와 내부 노드 사이에 있는 노드
- 리프노드: 자식 노드가 없는 노드

### 트리의 높이와 레벨

- 깊이: 루트 노드부터 특정 노드까지 최단거리로 갔을 때의 거리
- 높이: 루트노드부터 리프노드까지의 거리 중 가장 긴 거리
- 레벨: 문제 별 차이는 있지만 보통 깊이와 같은 의미를 가짐
- 서브트리: 트리 내의 하위 집합

### 이진 트리

자식의 노드 수가 두 개 이하인 트리를 의미함

- 정이진 트리(Full Binary Tree): 자식 노드의 개수가 0 또는 2인 이진 트리
- 완전 이진 트리(Complete Binary Tree): 왼쪽에서부터 채워져 있는 이진트리로, 마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져 있음
- 변빌 이진 트리(Degenerate Binary Tree): 자식 노드가 하나 밖에 없는 이진트리
- 포화 이진 트리(Perfect Binary Tree): 모든 노드가 꽉 차 있는 이진 트리를 의미
- 균형 이진 트리(Balanced Binary Tree): 왼쪽과 오른쪽 노드의 높이 차이가 1이하인 이진트리.(ex.map, set 을 구성하는 레드 블랙 트리)

### 이진 탐색 트리(BST)

노드의 오른쪽 하위 트리에는 노드보다 큰 값이 있는 노드들만 포함되고, 왼쪽 하위 트리에는 노드 값보다 작은 값이 들어 있는 트리

- 보통 요소를 찾을 때 O(logn) 이 소요되고 삽입 순서에 따라 선형적으로 설정될 경우 최악의 경우가 되어 O(n) 이 걸림

### AVL 트리(Adelson - Velsky and Landis Tree)

최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리.

- 두 자식 서브트리의 높이가 항상 최대 1만큼 차이 남(균형을 잡기 위해 트리를 왼쪽 혹은 오른쪽으로 회전시킴)
- 시간 복잡도: 탐색&삽입&삭제 - O(logn)

### 레드 블랙 트리

균형 이진 탐색 트리로 모든 리프노드와 루트 노드는 블랙이고, 어떠 ㄴ노드가 레드이면 그 노드의 자식들은 블랙이다 라는 규칙을 기반으로 균형을 잡음

- 시간 복잡도: 탐색&삽입&삭제 - O(logn)
- 각 노드가 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중에 트리가 균형을 유지할 수 있도록 사용함
- ex. C++ STL 의 set, multiset, map, and multipmap

## 힙

완전 이진 트리 기반의 자료 구조

- 최대힙: 루트 노드에 있는 키가 모든 자식에 있는 키 중에 가장 크며, 각 노드의 자식 노드와의 관계도 이 특징이 적용됨
- 최소힙: 루트 노드에 있는 키가 모든 자식에 있는 키 중에 가장 작고, 각 노드의 자식 노드와의 관계도 이 특징이 적용됨

### 최대힙의 삽입

1. 새로운 노드를 힙의 마지막 노드에 이어 삽입
2. 새로운 노드와 부모 노드들 과의 크기를 비교하며 교환해 힙의 성질을 만족 시킴

### 최대힙의 삭제

1. 최댓값인 루트 노드 삭제
2. 마지막 노드와 루트 노드를 스왑하여 재구성

## 우선순위 큐

우선순위 대기열이라고도 하며, 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조를 의미함

- 힙을 기반으로 구현

## 맵

특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조

- 레드 블랙 트리 자료 구조를 기반으로 형성
- 삽입 시 자동으로 정렬
- 배열과 비슷하게 `clear()` 함수로 모든 요소를 삭제할 수 있고 `size()` 로 map 크기를 구할 수 있음
- 해시 테이블을 구현할 때 쓰며 정렬을 보장하지 않는 unordered_map 과 정렬을 보장하는 map 두가지가 있음

## 셋
특정 순서에 따라 고유한 요소를 저장하는 컨테이너로 중복되는 요소는 없고 unique 값만 저장하는 자료구조

## 해시 테이블
무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블
- unordered_map 으로 구현
- 시간 복잡도: 삽입&삭제&탐색 - 평균적으로 O(1)

<br/><br/><br/><br/>

# 용어

- STL: C++의 표준 템블릿 라이브러리이자 스택, 배열 등 데이터 구조의 함수 등을 제공하는 라이브러리의 묶음
