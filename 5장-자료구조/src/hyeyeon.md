자료구조는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합을 의미

# 복잡도

## 시간 복잡도

#### 시간 복잡도란?

- 입력의 크기에 대해 어떠한 알고리즘이 실행되는 데 걸리는 시간
- 주요 로직의 반복 횟수를 중점으로 측정
- 보통 빅오 표기법으로 나타냄

#### 빅오 표기법

- 입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것
- 효율적인 코드로 개선하는 데 쓰이는 척도

#### 시간 복잡도의 속도 비교

- O(n^2) < O(n) < O(logn) < O(1) 순으로 빠름

## 공간 복잡도

- 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양

## 자료 구조 시간 복잡도

### 평균 시간 복잡도

|   자료 구조    |  접근   |  탐색   |  삽입   |  삭제   |
| :------------: | :-----: | :-----: | :-----: | :-----: |
|      배열      |  O(1)   |  O(n)   |  O(n)   |  O(n)   |
|      스택      |  O(n)   |  O(n)   |  O(1)   |  O(1)   |
|       큐       |  O(n)   |  O(n)   |  O(1)   |  O(1)   |
| 링크드 리스트  |  O(n)   |  O(n)   |  O(1)   |  O(1)   |
|  해시 테이블   |  O(1)   |  O(1)   |  O(1)   |  O(1)   |
| 이진 탐색 트리 | O(logn) | O(logn) | O(logn) | O(logn) |
|    AVL 트리    | O(logn) | O(logn) | O(logn) | O(logn) |
| 레드 블랙 트리 | O(logn) | O(logn) | O(logn) | O(logn) |

### 최악 시간 복잡도

|   자료 구조    |  접근   |  탐색   |  삽입   |  삭제   |
| :------------: | :-----: | :-----: | :-----: | :-----: |
|      배열      |  O(1)   |  O(n)   |  O(n)   |  O(n)   |
|      스택      |  O(n)   |  O(n)   |  O(1)   |  O(1)   |
|       큐       |  O(n)   |  O(n)   |  O(1)   |  O(1)   |
| 링크드 리스트  |  O(n)   |  O(n)   |  O(1)   |  O(1)   |
|  해시 테이블   |  O(n)   |  O(n)   |  O(n)   |  O(n)   |
| 이진 탐색 트리 |  O(n)   |  O(n)   |  O(n)   |  O(n)   |
|    AVL 트리    | O(logn) | O(logn) | O(logn) | O(logn) |
| 레드 블랙 트리 | O(logn) | O(logn) | O(logn) | O(logn) |

# 선형 자료 구조

## 연결 리스트

- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료구조
- prev 포인터와 next 포인터로 앞 뒤 노드를 연결

#### 종류

- 싱글 연결 리스트: next 포인터만 가짐
- 이중 연결 리스트: next 포인터와 prev 포인터를 가짐
- 원형 이중 연결 리스트: 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가르킴

## 배열

- 같은 타입의 변수들로 이루어져있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
- 중복을 허용하고 순서가 있음

#### 배열 vs 리스트 차이

- 배열 : 랜덤 접근이 가능
- 연결 리스트 : 랜덤 접근 불가능

## 벡터

- 동적으로 요소를 할당할 수 있는 동적 배열
- push_back을 사용시 기본으로 O(1)임, 근데 내부에서 크기를 늘릴 때 2의 제곱승 + 1 마다 크기를 2배 늘림

## 스택

- 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질을 가짐

## 큐

- 먼저 넣은 데이터가 먼저 나오는 성질을 가짐

# 비선형 자료 구조

## 그래프

- 정점과 간선으로 이루어진 자료 구조
- 단방향 간선 : a -> b
- 양방향 간선 : a <-> b
- 정점으로 나가는 간선을 해당 정점의 outdegree, 들어오는 간선은 indegree라고 한다.
- 가중치: 간선과 정점 사이에 드는 비용

정점과 간선으로 이루어져 있고, 트리 구조로 배열된 일종의 계층적 데이터의 집합

루트 노드, 내부 노드, 리프 노드 등으로 구성됨

## 트리

### 트리의 특징

1. 부모, 자식 계층 구조를 가짐
2. V - 1 = E. 간선 수는 노드 수 -1
3. 임의 두 노드 사이의 경로는 반드시 존재

### 트리의 구성

루트 노드 , 내부 노드, 리프 노드로 이루어져 있음

### 루트 노드

가장 위에 있는 노드를 뜻함

### 내부 노드

루트 노드와 내부 노드 사이에 있는 노드를 뜻함

### 리프 노드

자식 노드가 없는 노드

### 트리의 높이와 레벨

깊이: 트리에서의 깊이는 각 노드마다 더루며, 루트 노드로부터 거리

높이: 루트 노드부터 리프노드까지 거리 중 최장거리

레벨: 깊이와 동일한 의미

서브트리 : 트리 내의 하위 집합

### 이진 트리

자식의 노드 수가 두 개 이하인 트리를 의미

- 정이진 트리: 자식 노드가 0 또는 두 개인 이진 트리
- 완전 이진 트리: 왼쪽에서부터 채워져 있는 이진 트리
- 변질 이진 트리: 자신 노드가 하나밖에 없는 이진 트리
- 포화 이진 트리: 모든 노드가 꽉 차 있는 이진 트리
- 균형 이진 트리: 왼쪽과 오른쪽 노드의 높이 차이가 1이하인 이진 ㅊ틔

### 이진 탐색 트리

노드의 오른쪽 하위 트리에는 노드 값보다 큰 값, 왼쪽 하위에는 노드 값보다 작은 값

이렇게 두면 검색을 하기에 용이

요소를 찾을 때 이진탐색 트리의 경우 O(logn)이 걸린다 하지만 최악의 경우 O(n)이 걸림

그 이유는 삽입 순서에 따라 선형적일 수 있기 때문

### AVL 트리

최악의 경우 선형적인 트리가 방지하고 균형을 잡는 이진 탐색 트리

두 자식 서비트리의 높이 차를 1만큼만 둔다는 특징이 있음

탐색, 삽입, 삭제 모두 시간 복잡도 O(logn)임

탐색, 삽입, 삭제 시 균형이 안 맞는 것을 맞추기 위해 트리의 일부를 왼쪽 혹은 오른쪽으로 회전시키며 규형을 잡음

### 레드 블랙 트리

규형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)입니다.

각 노드는 빨간색 또는 검정색을 나타내는 추가 비트를 저장하며 삽입 및 삭제 중에 트리가 규형을 유지하도록 하는 데 사용

모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다. 등의 규칙을 기반으로 균형을 잡는 트리

## 힙

완전 이진 트리 기반의 자료 구조, 최소힙과 최대합 두 가지가 있음

해당 힙에 따라 특정한 특징을 지킨 트리를 말한다

- 최대힙 : 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야함 또한, 각 노드의 자식 노드와의 관계도 이롸 같은 특징이 있음
- 최소 힙: 루트가 모든 자식에 있는 키중 최소값

### 최대힙의 삽입

힙에 새로운 요소가 들어오면, 새로운 노드를 힙의 마지막 노드에 이어서 삽입

이 새로운 노드를 부모 노드들과 크기를 비교하며 교환해서 힙의 성질을 만족

### 최대힙의 삭제

로트 노드를 삭제하고 마지막 노드와 루트노드를 스왑해서 부모 노드들과 크기를 비교하며 교환해서 힙의 성질을 만족

## 우선 순위 큐

우선 순위 대기열이라고 하며, 대기열에서 우선 순위가 높은 요소가 우선 순위 낮은 요소보다 먼저 제공되는 자료 구조
힙을 기반으로 구현

## 맵

특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조

레드 블랙 트리 자료 구조를 기반으로 형성

삽입되면 자동으로 정렬됨

## 셋

특정 순서에 따라 고유한 요소를 저장하는 컨테이너, 중복되는 요소는 없고

오로지 희소한 값만 저장하는 자료 구조

## 해시 테이블

삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간 복잡도를 가지며 unordered_map으로 구현

모든 쌍의 거리를 다 구할 필요가 업삳
소규모 그룹내에서는 대표 노드끼리의 거리만 알면 된다.
루트노드와 대표 노드들이 있는 집합에서의 루트노드끼리의 거리만 알면된다
그 이유는 checktime함수는 루트노드끼리의 거리인데, 그 path는 간단히 하면
루트 -> 대표 -> 말단 -> 대표 -> 루트이다.

나눠보면 2가지로 나눌 수 있다
말단 노드를 거쳐서 대표노드끼리의 거리
대표노드를 거쳐서 루트노드끼리의 거리

말단 노드를 거쳐서 대표노드끼리의 거리

- 대표 노드들을 출발노드로 다익스트라를 돌릴수 있다
- 대표노드 3개 \* O(ElogV)

대표 노드를 거쳐서 루트노드끼리의 거리

- 루트노드를 출발 노드로 다익스트라를 돌릴수 이싿
- O(Elogv) => O()

루트 -> 대표 -> 말단 -> 대표 -> 루트만 이해했느데 나머지는 이해가 안돼
