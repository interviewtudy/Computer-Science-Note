# 데이터베이스의 기본

데이터베이스(DB, DataBase)는 일정한 규칙 혹은 규악을 통해 구조화되어 저장된 데이터들의 모음을 말함

- DBMS(Database Management System): 데이터베이스를 제어, 관리하는 통합 시스템
- DBMS마다 정의된 쿼리 언어를 통해 데이터 삽입, 삭제, 수정, 조회 할 수 있음
- 실시간 접근과 동시 공유 가능
- 응용프로그램 <-> DBMS <-> 데이터베이스

<br/><br/>

## 엔터티(Entity)

엔터티(entity)란 여러 개의 속성을 가진 명사를 의미함(ex.엔터티: 회원, 회원엔터티 속성: 이름, 아이디, 주소 등)

- 엔터티의 속성은 서비스의 요구사항에 따라 정해짐
- 혼자는 존재하지 못하고 다른 엔터티의 존재 여부에 종속적이면 약한 엔터티, 그렇지 않으면 강한 엔터티라고 함

<br/><br/>

## 릴레이션(Relation)

릴레이션(relation)이란 데이터베이스에서 정보를 구분하여 저장하는 기본 단위를 의미함

- 관계형 데이터베이스에선 **테이블**, NoSQL 데이터베이스에선 **컬렉션** 이라고 함
- MySQL 구조(관계형 데이터베이스): 레코드-테이블-데이터베이스 / MongoDB(NoSQL): 도큐먼트-컬렉션-데이터베이스
- 레코드(테이블의 한 행)가 쌓여서 테이블이 되고, 테이블이 쌓여서 DB가 됨

<br/><br/>

## 속성(Attribute)

속성(attribute)이란 릴레이션에서 관리하는 구체적이고 고유한 이름을 갖는 정보를 의미함

<br/><br/>

## 도메인(Domain)

도메인(domain)이란 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값들의 집합을 의미함(ex.성별 속성의 도메인은 {남, 여})

<br/><br/>

## 필드와 레코드

- 엔터티 - 테이블(ex. 회원 엔터티 - member 테이블)
- 속성 - 필드(ex. 이름, 성별, 주소 속성 - name, gender, address 필드)
- 테이블 행 - 레코드(튜플이라고도 함)

### 필드 타입

#### 숫자 타입

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등

#### 날짜 타입

| 타입      | 표현 데이터 | 용량    |
| --------- | ----------- | ------- |
| DATE      | 날짜만      | 3바이트 |
| DATETIME  | 날짜+시간   | 8바이트 |
| TIMESTAMP | 날짜+시간   | 4바이트 |

#### 문자 타입

CHAR, VARCHAR, TEXT, BLOB, ENUM, SET

- CHAR, VARCHAR
  - 수를 입력해서 몇 자까지 입력할지 정할 수 있음(ex.CHAR(10), VARCHAR(100))
  - CHAR 는 레코드의 값과 무관하게 고정 길이로 저장, VARCHAR 는 입력된 데이터에 따라 가변 길이로 저장
- TEXT, BLOB
  - 큰 데이터를 저장할 때 쓰는 타입으로 TEXT 는 긴 문자열, BLOB 은 이미지, 동영상 등을 저장함
  - 단 요즘은 이미지 호스팅 서비스인 s3 서비스를 사용하는 등 서버에 파일 업로드 후 경로를 VARCHAR 로 저장하는 경우가 많음
- ENUM, SET

  <table>
    <thead>
      <tr>
        <th colspan="2">항목</th>
        <th>ENUM</th>
        <th>SET</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td rowspan="2">공통점</td>
        <td>장점</td>
        <td colspan="2">메모리를 적게 사용함</td>
      </tr>
      <tr>
        <td>단점</td>
        <td colspan="2">애플리 케이션 수정이 생기면 정의한 목록 수정해야 함</td>
      </tr>
      <tr>
        <td rowspan="4">차이점</td>
        <td>선택 가능한 값 수</td>
        <td>단일 선택</td>
        <td>다중 선택</td>
      </tr>
      <tr>
        <td>저장 방식</td>
        <td>내부적으로 숫자 인덱스로 저장</td>
        <td>비트 필드로 저장</td>
      </tr>
      <tr>
        <td>비트 연산</td>
        <td>X(하나만 선택 하기 때문에 불필요)</td>
        <td>O</td>
      </tr>
      <tr>
        <td>최대 요소 개수</td>
        <td>65,535개</td>
        <td>64개</td>
      </tr>

    </tbody>
  </table>

  - 문자열을 열거한 타입(ex. ENUM('option1', 'option2'), SET('option1', 'option2'))
  - ENUM 타입에서 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됨

<br/><br/>

## 관계

- DB에는 여러개의 테이블이 정의되어 있고 서로의 관계가 정의되어있음
- 관계는 관계화살표로 나타냄
  <img src="https://blog.kakaocdn.net/dn/bcwCAD/btrhMtkXNcd/gAkHT1rMWKPWTIQezHEKu0/img.jpg">

### 1:1 관계

- ex.유저 테이블 - 유저 이메일 테이블
- 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 함

### 1:N 관계

- ex. 유저 테이블 - 상품 테이블(한 장바구니에 0개 이상의 상품)
- 한 개체가 다른 많은 개체를 포함하는 관계

### N:M 관계

- ex. 학생 테이블 - 강의 테이블(학생이 여러개의 강의 수강, 강의에 여려 학생이 포함)
- 두 테이블을 직접적으로 연결해서 구축하지 않고, 각 테이블과 1:N, 1:M 이라는 관계를 갖는 테이블을 만들어 설정함

<br/><br/>

## 키

키는 테이블 간의 관계를 좀 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치

- 기본키, 외래키, 후보키, 슈퍼키, 대체키가 존재함
- 기본키, 대체키 ⊂ 후보키 ⊂ 슈퍼키
- 슈퍼키는 유일성, 후보키는 최소성까지 갖춤. 후보키 중에서 기본키로 선택되지 못한 키는 대체키가 됨
- 유일성: 중복되는 값이 없음
- 최소성: 필드 조합 없이 최소 필드만 써서 키를 형성할 수 있음

### 기본키(PK, Primary Key)

- 유일성과 최소성을 만족함
- 자연키와 인조키 중에 골라서 설정함
- 자연키: 자연스럽게 나오는 속성. 언젠간 변하는 속성을 가짐
- 인조키: 인위적으로 아이디를 부여해 만들어진 고유 식별자. 오라클은 sequence, MySQL 은 auto increment 등으로 설정함. 속성이 변하지 않음. 보통 인조키가 기본키로 설정됨

### 외래키(FK, Foreign Key)

다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용. 중복이 가능함

### 후보키(Candidate Key)

기본키가 될 수 있는 후보들로 유일성과 최소성을 동시에 만족시킴

### 대체키(Alternate Key)

후보키가 두 개 이상일 경우 기본키로 설정된 것을 제외한 남은 후보키들

### 슈퍼키(Super Key)

각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

<br/><br/><br/><br/>

# ERD 와 정규화 과정

ERD(Entity Relationship Diagram)은 릴레이션 간의 관계들을 정의한 것을 의미함

## ERD의 중요성

- 시스템 요구 사항을 기반으로 작성 되며 ERD 를 기반으로 데이터베이스를 구축함
- 데이터베이스 구축 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요할 때 설계도 역할을 함
- 장점: 관계형 구조로 표현 가능한 데이터를 구성하는 데 유용
- 단점: 비정형 데이터를 충분히 표현할 수 없음

## 정규화 과정

정규화 과정이란 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정을 말함

- 정규형 원칙을 기반으로 정규형을 만들어가고 정규화된 정도는 정규형(NF, Normal Form)으로 표현
- 기본 정규형: 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형
- 고급 정규형: 제4정규형, 제5정규형
- 정규형 과정을 거쳐 테이블을 나눠도 성능이 100% 좋아지는 것은 아님. 조인이 필요해지는 경우가 생겨 느려질 수 있기 때문에 서비스에 따라 정규화/비정규화를 진행해야 함

### 정규형 원칙

- 자료의 중복성은 감소해야 함
- 독립적인 관계는 별개의 릴레이션으로 표현해야 함
- 각각의 릴레이션은 독립적인 표현이 가능해야 함

### 제1정규형

- 릴레이션의 모든 도메인이 더이상 분리될 수 없는 원자 값만으로 구성되어야 함
- 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어선 안됨
- 반복 집합이 있다면 제거

### 제2정규형

- 릴레이션이 제1정규형이고 부분 함수의 종속성을 제거한 형태(기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말함)
- 릴레이션 분해 시 동등한 릴레이션으로 분해해야 하고 무손실 분해로 분해되어야 함

### 제3정규형

제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)를 만족해지 않는 상태

#### 이행적 함수 종속

A->B 와 B->C 가 존재하면 A->C 가 성립하는데, 이때 C가 집합 A에 이행적으로 함수 종속이 되었다고 함

### 보이스/코드 정규형(BCNF)

제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말함

<br/><br/><br/><br/>

# 트랜잭션과 무결성

## 트랜잭션

트랜잭션이란 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 의미함

- 쿼리: 데이터베이스에 접근하는 방법
- 트랜잭션: 여러개의 쿼리를 하나로 묶는 단위
- ACID 특징: 원자성, 일관성, 독립성, 지속성

### 원자성(Atomicity)

트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징

- 여러 로직을 묶을 때 외부 API를 호출하는 것이 있으면 안됨. 있을 경우 롤백이 일어났을 때 어떻게 할 것인지에 대한 해결방안이 있어야 함

#### 커밋과 롤백

- 커밋(commit): 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어. 트랜잭션 단위로 수행되고 변경된 내용이 영구적으로 저장됨( == 하나의 트랜잭션 성공)
- 롤백: 트랜잭션 전으로 돌리는 일

#### 트랜잭션 전파

트랜잭션은 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨줘야 하는데, 매번 넘겨주는 번거로움을 해결하기 위해 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는것을 의미함

### 일관성(Consistency)

**허용된 방식**으로만 데이터를 변경해야 하는것을 의미함<br/>
(ex.0원인 계좌에서 500만원을 빠져나가게 할 수 없음)

### 격리성(Isolation)

트랜잭션 수행 시 서로 끼어들지 못하는 것을 의미함

#### 격리 수준에 따라 발생하는 현상

- 팬텀 리드(Phantom read): 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 조회 결과가 다름
- 반복 가능하지 않은 조회(Non-repeatable read): 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우<br/>
  팬텀리드는 다른 행이 선택될 수도 있지만, 반복 가능하지 않느 조회는 같은 행에 대한 현상임
- 더티 리드(Dirty read): 아직 커밋되지 않은 행의 데이터를 읽게되어 발생하는 현상임

#### 격리 수준

위에서 아래로 갈수록 동시성이 강해지고, 격리성이 약해짐

| 격리 수준        | 설명                                                                                                                                                                                           | 현상                                          |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- |
| SERIALIZABLE     | 트랜잭션을 순차적으로 진행시킴. 교착상태 일어날 확률이 많고 성능이 가장 떨어짐                                                                                                                 | X                                             |
| REPEATABLE_READ  | 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막음. 단, 새로운 행의 추가는 막지 않음                                                                                          | 팬텀 리드                                     |
| REPEATABLE_READ  | 가장 많이 사용되는 격리 수준. MySQL8.0, PostgreSQL, SQL Server, 오라클의 기본값. 커밋 완료된 데이터에서만 조회를 허용함.                                                                       | 팬텀 리드, 반복 가능 하지 않은 조회           |
| READ_UNCOMMITTED | 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출될 수 있음. 가장 빠름. 데이터 무결성을 위해선 되도록 사용하지 않는 것이 이상적이지만 거대한 양의 데이터를 어림잡는 용으로 사용하기 좋음. | 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드 |

<br/><br/>

### 지속성(Durability)

성공적으로 수행한 트랜잭션은 영원히 반영되어야 하는 거을 의미함

- 시스템 장애가 발생해도 원래 상태로 복구할 수 있어야 함
- 체크섬, 저널링, 롤백 기능을 통해 지속성을 유지하려고 함

<br/><br/>

## 무결성

데이터의 정확성, 일관성, 유효성을 유지하는 것을 의미함

- 개체 무결성: 기본키로 선택된 필드는 빈 값을 허용하지 않음
- 참조 무결성: 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함
- 고유 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐
- NULL 무결성: 특정 속성 값에 NULL 이 올 수 없다는 조건이 주어진 경우, 그 속성은 NULL 이 될 수 없다는 제약 조건

<br/><br/><br/><br/>

# 데이터베이스의 종류

## 관계형 데이터베이스(RDBMS)

행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가리킴

- SQL 이라는 언어를 써서 조작
- MySQL, PostgreSQL, 오라클, SQL, MSSQL 등
- 표준 SQL 을 지키지만 각 제품에 특화시킨 SQL 을 사용함

### MySQL

- 대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스
- C, C++ 로 만들어짐
- MyISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템 등 최대 64개의 인덱스를 제공
- 대용량 데이터베이스를 위해 설계
- 롤백, 커밋, 이중 암호 지원 보안 등의 기능을 제공함
- 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꾸는 것이 가능함
- 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점을 두고 있음
- 스토리지 엔진 위에 커넥터 API 및 서비스 계층을 통해 MySQL 데이터베이스와 쉽게 상호 작용 가능
- MySQL 은 쿼리 캐시를 지원해서 입력된 쿼리 문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시함

### PostgreSQL

- 디스크 조각이 차지하는 영역을 회수할 수 있는 VACUUM 이 특징
- 최대 테이블 크기는 32TB
- SQL 뿐 아니라 JSON 을 사용해서 데이터 접근 가능
- 지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등을 할 수 있음

<br/><br/>

## NoSQL 데이터베이스

- Not only SQL 이라는 슬로건에서 생겨난 데이터 베이스
- SQL을 사용하지 않는 데이터 베이스
- MongoDB, redis 등

### MongoDB

- JSON을 통해 데이터에 접근 가능
- Binary JSON(BJSON) 형태로 데이터가 저장되며 와이드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스
- 확장성이 뛰어남, 빅데이터 저장시 성능 좋음, 고용성, 샤딩과 레플리카셋을 지원함, 스키마를 저장하지 않고 데이터를 삽입할 수 있어 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현하기 좋음, 유니크 값인 ObjectID 가 생성됨

### redis

- 인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스
- 기본적인 데이터 타입은 문자열(string)으로 최대 512MB 까지 저장 가능, 셋(set), 해쉬(hash) 등을 지원함
- pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된(sortted set) 자료 구조를 이용한 실시간 순위표 서비스에 사용

<br/><br/><br/><br/>

# 인덱스

## 인덱스의 필요성

인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치를 의미함.

<br/><br/>

## B-트리

- 루트 노드, 리프 노드, 브랜치 노드로 나뉨
- 인덱스는 효율적인 단계에 거쳐 모든 요소에 접근하 ㄹ수 있는 균형잡힌 트리 구조와 트리 깊이의 대수 확장성 때문에 효율적임
- 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미함

<br/><br/>

## 인덱스 만드는 방법

### MySQL

- 클러스터형 인덱스와 세컨더리 엔덱스가 있음
- 클러스터형 인덱스: 테이블 당 하나. PK 옵션으로 기본키를 만들었을 때 생성이 가능하고 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있음
- 세컨더리 인덱스: create index... 명령어를 기반으로 생성, 하나의 인덱스 생성 시 클러스터형 보다 성능이 좋음. 여러개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스

### MongoDB

- ObjectID 가 기본키
- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스 설정 가능

<br/><br/>

## 인덱스 최적화 기법

1. 인덱스는 비용이다<br/>
   인덱스 리스트 -> 컬렉션 순으로 탐색하기 때문에 읽기 비용, 컬렉션 수정으로 인한 인덱스 수정 시 B-트리 높이를 균형있게 하기 위해 조정하는 비용, 효율적 조회를 위한 분산 비용 발생<br/>
   쿼리에 있는 필드에 인덱스를 무조건 다 설정하지 않고 컬렉션에서 가져와야 하는 양이 많을수록 인덱스 사용이 비효율적임
2. 항상 테스팅하라<br/>
   `explain()` 함수를 통해 인덱스를 만들고 쿼리를 보낸 후 테스팅을 하며 걸리는 시간을 최소화 해함
3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

<br/><br/><br/><br/>

# 조인의 종류

조인(join)이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말함.

- MySQL 에선 JOIN, MongoDB 에선 lookup 사용
- lookup 은 되도록 사용하지 말아야 함

## 설명

- 내부 조인(inner join): 두 테이블 간의 교집합
- 왼쪽 조인(left outer join): 왼쪽 테이블의 모든행이 결과 테이블에 표기됨. 오른쪽 테이블에 일치하는 항목이 없으면 null 로 표기
- 오른쪽 조인(right outer join): 오른쪽 테이블의 모든행이 결과 테이블에 표기됨. 왼쪽 테이블에 일치하는 항목이 없으면 null 로 표기
- 합집합 조인(full outer join): 두 테이블의 합집합이 결과 테이블에 표기됨. 일치하는 항목이 없으면 누락된 쪽에 null 이 포함되어 출력됨

<br/><br/><br/><br/>

# 조인의 원리

## 중첩 루프 조인(NLJ, Nested Loop Join)

중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법

- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에선 사용하지 않음
- 발전한 형태로 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 블록 중첩 루프 조인(BNL, Block Nested Lop)이 있음

<br/><br/>

## 정렬 병합 조인

각 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인

- 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블을 조인하고 조인조건으로 <, > 등 범위 비교 연산자가 있을 때 사용

<br/><br/>

## 해시 조인

해시 테이블을 기반으로 조인하는 방법

- 두 개의 테이블을 조인한다고 할 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적임(더 크면 디스크 사용 비용이 발생함)
- 동등(=) 조인에서만 사용 가능
- MySQL의 해시 조인 단계는 빌드 단계와 프로브 단계로 나뉨

### 빌드 단계

입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드 하는 단계

- 둘 중 바이트가 더 작은 테이블을 기반으로 생성
- 조인에 사용되는 필드가 해시 테이블의 키로 사용됨

### 프로브 단계

레코드 읽기를 시작해 일치하는 레코드를 찾아서 결과값으로 반환함

- 각 테이블은 한 번씩만 읽게 되어 중첩 루프 조인보다 보통은 성능이 더 좋음
- 사용 가능한 메모리 양은 시스템 변수 join_buffer_size 에 의해 제어되며 런타임 시 조정이 가능함

<br/><br/><br/><br/>

# 용어

- 비정형 데이터: 비구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보를 말함
- 결정자: 함수 종속 관계에서 특정 종속자를 결정 짓는 요소. X -> Y 일 때, X는 결정자, Y는 종속자
- 체크섬: 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법.
- 저널링: 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것. 트랜잭션 등 변경 사항에 대한 로그를 남기는 것
