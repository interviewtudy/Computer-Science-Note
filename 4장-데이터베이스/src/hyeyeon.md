# 데이터베이스의 기본

- DB: 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음

  - 실시간 접근과 동시 공유가 가능

- DBMS: DB제어, 관리하는 통합 시스템

  - DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행 할 수 있습니다.

- DB <-> DBMS <-> 응용프로그램, 이러한 구조를 기반으로 데이터를 주고 받는다.

## 엔터티

| 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미 (서비스의 요구 사항에 맞춰서 속성이 정해진다)

### 약한 엔터티와 강한 엔터티

|약한 엔터티|강한 엔터티|
|혼자서 존재 X, 다른 엔터티에 종속적|다른 엔터티가 종속되는 구조를 가질 수 있음|

## 릴레이션

| 데이터베이스에서 정보를 구분하여 저장하는 기본 단위, 엔터티에 관한 데이터를 DB는 릴레이션 하나에 담아서 관리
SQL = 테이블, NoSQL = 컬렉션

### 테이블과 컬렉션

Mysql = 레코드-테이블-데이터베이스
MongoDB = 도큐먼트-컬렉션-데이터베이스

## 속성

| 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보, 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들

## 도메인

릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

## 필드와 레코드

| DB에서 필드와 레코드로 구성된 테이블을 만들 수 있음
레코드 = 튜플

### 필드 타입

**날짜 타입**</br>

- DATE: 시간 없이 날짜만
- DATETIME: 날짜 및 시간 부분 포함 (1000년부터 9999년까지 가능 8바이트)
- TIMESTAMP: 날짜 및 시간 부분 포함(1970년부터 2038년까지 가능 4바이트)

**문자타입**</br>

- CAHR: 고정 길이 문자열(0~255글자까지 가능)
- VARCHAR: 가변 길이 문자열(0~65,535글자까지 가능), 저장될 떄 글자수 + 길이기록용 1바이트로 저장하게 됨
- TEXT: 큰 문자열 저장에 쓰임, 게시판 본문을 저장할 때 사용
- BLOB: 이미지, 동영상 등 큰 데이터 저장에 사용
- ENUM: 중에서 하나만 선택하는 방식, 리스트에 없는 값을 고르면 빈 문자열이 대신 삽입
- SET: 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있다

## 관계

여러개의 테이블간의 관계를 정의할 때 관계 화살표를 이용

- 1:1 관계
- 1:N 관계
- N:N 관계

# 키

## 기본키

| 유일성(중복 x)과 최소성을 만족, 자연키 또는 인조키 중에 골라 설정

- 자연키 : 중복되지 않는게 자연스럽게 나오는 키..?, 자연키는 언제가는 변하는 속성을 가짐
- 인조키 : 인위적으로 유저 아이디를 부여하는 식의 방식

## 왜리키

| 다른 테이블의 기본키를 그대로 참조하는 값, 개체와의 관계를 식별하는 데 사용

- 중복 가능

## 후보키

| 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키

## 대체키

| 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키

## 슈퍼키

| 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

# ERD와 정규화 과정

릴레이션 간의 관계들을 정의한 것

## ERD의 중요성

시스템 요구 사항을 기반으로 작성되며 이 ERD를 기반으로 DB 구축
구축된 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설게도 역할을 담당

단점: 비정형 데이터를 충분히 표형 할 수 없다는 단점이 존재

## 정규화 과정

릴레이션 간의 잘못된 종속 관계로 인해 디비 이상 형상이 일어나 이를 해결하거나 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개호 분리하는 과정

원칙: 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야 함, 자료의 중복성은 감소, 독립적인 관계는 별개의 릴레이션으로 표현해야함, 각각의 릴레이션은 독립적인 표현이 가능해야 함

| 정규화 과정        | 설명                                                               |
| ------------------ | ------------------------------------------------------------------ |
| 제 1 정규형        | 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값만으로 구성 |
| 제 2 정규형        | 부분 함수 종속성 제거                                              |
| 제 3 정규형        | 이행적 함수 종속을 만족하지 않는 상태                              |
| 보이스/코드 정규형 | 결정자가 후보키가 아닌 함수 종속 관계를 제거                       |

# 트랜잭션과 무결성

## 트랜잭션

| 디비에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
디비에 접근하는 방법은 쿼리이므로, 여러 개의 쿼리들을 하나로 묶는 단위이다.

ACID 특징: 원자성, 일관성, 독립성, 지속성

### 원자성

|트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징

#### 커밋과 롤백

커밋: 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어, 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것
롤백: 에러나 이슈로 트랜잭션 전으로 돌려야 한다면 사용 하는 것

커밋과 롤백 덕에 데이터의 무결성이 보장된다.

#### 트랜잭션 전파

| 트랜잭션을 수행할 때 커넥션 단위로 수행함, 커넥션 객체를 넘겨서 수행해야함
하지만 이를 매번 넘겨주기가 어렵고 귀찮기에 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 한다.

### 일관성

| 허용된 방식으로만 데이터를 변경해야하는 것

### 격리성

| 트랜잭션 수행 시 서로 끼어들지 못하는 것
복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동 되어야 함 -> 그냥 순차적으로 하면 성능이 나쁨

격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장

#### 격리 수준에 따라 발생하는 현상

- 패텀 리드: 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말합니다.
- 반복 가능하지 않은 조회: 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킵니다.
  - 팬텀리드와 다른 점은 반복 가능하지 않은 조회는 행 값이 달라질 수도 있는데, 팬텀 리드는 다른 행이 선택될 수도 있다는 것을 의미합니다.
- 더티리드:
  반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이털르 읽을 수 있을 때 발생합니다.

#### 격리 수준

| 수준               | 설명                                                                                                                                                                                                                                                                                       |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| SERIALIZABLE       | - 트랜잭션을 순차적으로 진행시키는 것</br> - 여러 트랜잭션이 동시에 같은 행에 접근할 수 없음</br> - 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 기다려야 함</br> - 그러기에 교착 상태가 일어날 확률도 많고 가장 성능이 떨어지는 격리 수준</br> |
| REPEATABLE_READ    | - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아줌</br> -BUT, 새로운 행을 추가하는 것은 막지 않음 </br> - 따라서 이후에 추가된 행이 발견될 수도 있다.                                                                                                                 |
| READ_COMMITTED     | - 가장 많이 사용되는 격리 수준</br> - READ UNCOMMITTED와는 달리 다른 트랜잭션이 커믹하지 않은 정보는 읽을 수 없음</br> - 즉, 커밋 완료된 데이터에 대해서만 조회를 허용</br> - 하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있음                                            |
| READ\_ UNCOMMITTED | - 가장 낮은 격리 수준</br> - 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠름</br> - 데이터 무결성을 위해 되도록이면 사용하지 않는 것이 이상적임</br> - 거대한 양의 데이터를 어림잡아 집계하는 데는 사용하면 좋음                                        |

### 지속성

| 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미합니다. 이는 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함을 뜻하며, 데이터 베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공합니다.

- 체크섬 : 중복 검사의 한 형태로, 오류 정정을 통헤 송신된 자료의 무결성을 보호하는 단순한 방법
- 저널링: 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

# 데이터베이스의 종류

## 관게형 데이터베이스

| 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스르 가리키며 SQL언어를 써서 조작

### MYSQL

대부분의 운영체제와 호환되며 현재 가장 많이 사용한느 데이터베이스입니다.
모듈식 아키텍쳐로 쉽게 스토리지 엔진을 바꿀 수 있으며 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점을 두고 있습니다. 스토리지 엔진 위에는 커넥터 API 및 서비스 계층을 통해 Mysql 데이터베이스와 쉽게 상호 작용할 수 있습니다.
또한, Mysql은 쿼리 캐시를 지원해서 입력된 쿼리문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시합니다

### PostgreSQL

- 디스크 조각이 차지하는 영역을 회수 할 있는 장치인 VACUUM이 특징
- SQL뿐만 아니라 JSON을 이용해서 데이터에 접근할 수 있다
- 지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등을 할 수 있음

## NoSQL 데이터베이스

### Mongo Db

JSON을 통해 데이터에 접근할 수 있고 binary JSON 형태로 데이터가 저장되며 와이어드타이거 엔진이 기본 스토리지 엔진으로 정착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스입니다. 확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋고 고가용성과 샤딩, 레플리카셋을 지원합니다, 또한, 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 떄문에 다양한 도메인의 데이터베이스를 기반으로 분석하거아 로깅 등을 구현할 때 강점을 보입니다.
또한 MongoDb는 도큐먼트를 생성할 떄마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니키한 값인 ObjectID가 생성됩니다.
이는 기본키로 유닉스 시간 기반의 타임 스탬프, 랜덤 값, 카운터로 이루어져 있다

### Redis

인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스입니다.
기본적인 데이터 타입은 무낮열이며 최대 512MB까지 저장할 수 있습니다, 이외에도 셋, 해시 등을 지원합니다
pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순히 키-값 필요한 세션 정보 관리, 정렬된 셋 자료 구조를 이용한 실시간 순위표 서비스에 사용

# 인덱스

| 데이터를 빠르게 찾을 수 있는 장치

## B-트리

|인덱스는 보통 B-트리 자료 구조로 이루어져 있음

루트 노드, 리프 노드, 브랜치 노드
루트 노드부터 시작해서 마지막 리프 노드에 도달함

핵심 아이디어: 값을 찾을 때 전체 테이블을 탐색하는 것이 아니라 **값이 있을 법한 리프노드**로 들어감

루트노드 -> 브랜치 노드 -> 리프 노드까지 '<='를 기반으로 탐색함

### 인덱스가 효율적인 이유와 대수확장성

이유: 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 **대수확장성** 때문

#### 대수확장성

트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미

기본적으로 인덱스가 한 깊이씩 증가할 떄마다 최대 인덱스 항목의 수는 4배 증가

### 인덱스 만드는 방법

#### MySQL

1. 클러스터 형 인덱스

   - 테이블 당 하나 설정 가능
   - PK 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있음
   - unique not null 옵션을 붙이면 만들 수 있다

2. 세컨더리 인덱스
   - create index 쿼리 명령어를 기반으로 만듬
   - 보조 인덱스, 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성

하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 게 세컨더리 인덱스를 만드는 것보다 성능이 좋다

#### MongoDB

- 도큐먼트를 만들면 자동으로 ObjectID가 형성, 해당 키가 기본키로 설정됨
- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있음

### 인덱스 최적화 기법

1. 인덱스는 비용이다

   - 인덱스는 두 번 탐색하도록 강요 (인덱스 리스트 -> 컬렉션 순 탐색)
     - 관련 비용이 들게 됨
   - 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다
     - 이때 B-트리의 높이를 규형 있게 조절하는 비용이 듬, 또한 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 된다.
   - 컬렉션에서 가져와야 하는 양이 많을수록 인덱스르 사용하는 것이 비효율적

2. 항상 테스팅하라

   - 서비스에서 사용하는 객체의 깊이, 테이브 양 등 서비스 특징에 따라 최적화 기법이 달라짐
     - 항상 테스팅 해야함
     - explain 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅하며 걸리는 시간을 최소화해야한다.

3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순
   - 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성
     - 인덱스를 생성할 떄에 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다
     - 같음 -> 정렬 -> 다중 값 -> 카디널리티 순으로 생성해야함

# 조인의 종류

| 조인이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

- MySQL에서는 JSON이라는 쿼리로 처리
- MongoDB에서는 lookup이라는 쿼리로 처리
  - 조인 연산에 대해 관계형 데이터베이스보다 성능이 떨어지니 되도록 사용하지 말아야 한다.
  - 여러 테이블을 조인하는 작업이 많을 경우 관계형 데이터베이스 사용

## INNER JOIN 내부 조인

| 두 테이블 간에 교집합을 나타냅니다.

- 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기합니다.

```
SELECT * FROM tablea A INNER JOIN tableb B ON A.key = B.key
```

## LEFT OUTER JOIN 왼쪽 조인

| 왼쪽 테이블의 모든 행이 결과 테이블에 표기됩니다.

- 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합을 생성합니다.
- 만약 테이블 B에 일치하는 항목이 없으면 해당 값은 null 값이 됩니다.

```
SELECT * FROM tablea A LEFT JOIN tableb B ON A.key = B.key
```

## RIGHT OUTER JOIN 오른쪽 조인

| 오른쪽 테이블의 모든 행이 결과 테이블에 표기됩니다

- 오른쪽 조인은 테이블 A에서 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합을 생성
- 만약 테이블 A에 일치하는 항목이 없으면 해당 값은 null 값이 됩니다.

```
SELECT * FROM tablea A RIGHT JOIN tableb B ON A.key = B.key
```

## FULL OUTER JOIN 합집합 조인

| 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기 합니다.

- 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성합니다.
- 이때 일치하는 항목이 없으면 누락된 쪽에 null값이 포함되어 출력됩니다

```
SELECT * FROM tablea A FULL OUTER JOIN tableb B ON A.key = B.key
```

# 조인의 원리

## 중첩 루프 조인

조건에 맞는 조인을 하는 방법, 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않습니다.

첫 번째 테이블에서 행을 한 번에 하나씩 찾고 그 다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결과값을 반환합니다

중접 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나워서 블록 하나씩 조인하는 블록 중첩 루프 조인이라는 방식도 있음

## 정렬 병합 조인

각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행한느 조인입니다. 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <,> 등 범위 비교 연산자가 있을 때 사용

## 해시 조인

해시 테이블을 기반으로 조인한느 방법. 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적입니다. 또한, 동등 조인에서만 사용할 수 있습니다.

mysql의 경우 해시 조인 단계는 빌드 단계, 프로브 단계로 나뉩니다.

### 빌드 단계

입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계입니다.
둘 중에 바이트가 더 작은 테이블을 기반으로 해서 테이블을 빌드합니다. 또한, 조인에 사용되는 필드가 해시 테이블의 키로 사용됩니다.

### 프로브 단계

레코드 일기를 시작하며, 각 레코드에서 일치하는 레코드를 찾아서 결괏값으로 반환합니다.
이를 통해 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋습니다. 참고로 사용 가능한 메모리양은 시스템 변수에 의해 제어되며, 런타임 시에 조정할 수 있습니다.
