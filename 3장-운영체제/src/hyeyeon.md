[운영체제와 컴퓨터](#운영체제와-컴퓨터)
[메모리](#메모리-1)
[프로세스와 스레드]()
[CPU 스케줄링 알고리즘]()

**OS** : 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스, 한정된 메모리나 시스템 자원을 효율적으로 분배함 </br>
**펌웨어** : 운영체제와 유사하지만 소프트웨어를 추가로 설치할 수 없는 것</br>
**GUI** : 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호작용하는 것</br>
**드라이버** : 하드웨어를 제어하기 위한 소프트웨어</br>
**CUI** : 그래픽이 아닌 명령어로 처리하는 인터페이스</br>
I/O 요청: 입출력 함수, 데이터베이스, 네트워크, 파일 접근 등에 관한 일</br>
드라이버: 하드웨어를 제어하기 위한 소프트웨어</br>
유저모드: 유저가 접근할 수 있는 영역을 제한적으로 두어 컴퓨터 자원에 함부로 침법하지 못하는 코드</br>
커널모드: 모든 컴퓨터 자원에 접근할 수 있는 모드</br>
커널: 시스템 콜을 제공하며, 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역할</br>

# 운영체제와 컴퓨터

| 하드웨어와 소프트웨어를 관리하는 일꾼인 운영체제 & CPU, 메모리 등으로 이루어진 컴퓨터

## 운영체제의 역할과 구조

### 운영체제의 역할

1. **CPU 스케쥴링과 프로세스 관리**:
   - CPU 소유권을 어떤 프로세스에 할당할지
   - 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리
2. **메모리 관리**:
   - 한정된 메모리를 어떤 프로세스에 얼마큼 할당해야 하는지 관리
3. **디스크 파일 관리**:
   - 디스크 파일을 어떠한 방법으로 보관할지 관리
4. **I/O 디바이스 관리**:
   - I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리

### 운영체제의 구조

|    운영체제 구조     |
| :------------------: |
|    유저 프로그램     |
| 인터페이스(GUI, CUI) |
|      시스템 콜       |
|         커널         |
|       하드웨어       |

- 유저 프로그램이 맨 위
- 그다음으로 GUI, 시스템콜, 커널, 드라이브가 있으며 가장 밑에 하드웨어가 있는 구조
- **GUI, 시스템콜, 커널, 드라이브 부분**이 바로 **운영체제**를 지칭

참고로 GUI가 없고 CUI만 있는 리눅스 서버도 있음

#### 시스템 콜

- 운영체제가 커널에 접근하기 위한 인터페이스
- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 쓴다
- 유저 프로그램이 I/O 요청으로 트랩을 발동하면 올바른 I/O 요청인지 확인한 후 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행
  - 장점: 컴퓨터 자원에 대한 직접 접근을 차단, 다른 프로그램으로부터 프로그램을 보호 가능

##### 프로세스나 스레드에서 운영체제로 요청 시 전달 단계

| 메모리, 프로세스, 스레드 -> 시스템콜 -> 커널 -> OS

**시스템 콜은 하나의 추상화 계층**
장점: 낮은 단계(네트워크 통신, 데이터베이스)의 영역 처리에 대한 부분은 신경쓰지 않고 프로그램을 구현할 수 있다.

**modebit**: 시스템콜이 작동될 때 modebit을 참괘서 유저 모드(1)와 커널 모드(0)를 구분합니다.

## 컴퓨터의 요소

CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러으로 이루어져있음

### CPU

- 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행하는 일꾼

#### 제어장치

- 프로세스를 조작하는 CPU의 부품
- 입출력 장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정

#### 레지스터

- CPU 안에 있는 빠른 임시기억장치(메모리보다 빠름)
- CPU는 자체적으로 데이터를 저장할 방법이 없기에 레지스터를 거쳐 데이터를 전달

#### 산술논리연산장치

- 산술 연산과 베타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로

**CPU의 연산처리** </br>

1. 메모리에 계산할 값을 로드 + 레지스터로 로드
2. 레지스터에 있는 값 계산하라고 산술 논리 연산장치에 명령
3. 다시 레지스터에서 메모리로 계산한 값을 저장

#### 인터럽트

- 어떤 신호(프로세스 오류 등)가 들어왔을 때 CPU를 잠시 정지시키는 것
- 인터럽트가 발생되면 핸들러 함수가 모여 있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실행
- 인터럽트 간에 우선순위가 있고 그 순위에 따라 실행

|       구분        |                  발생 원인                   | 동작 과정                                                                                                                                                                                                                                                                                                                                                                                                 |
| :---------------: | :------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 하드웨어 인터럽트 | I/O 디바이스(예: 키보드, 마우스 등)에서 발생 | 1. I/O 디바이스에서 이벤트가 발생하면, 해당 신호가 인터럽트 라인을 통해 CPU로 전달됩니다.</br>2.CPU는 현재 실행 중인 작업을 잠시 중단하고, 인터럽트 벡터 테이블에 등록된 해당 인터럽트 핸들러로 제어를 넘깁니다.</br>3.필요에 따라, 디바이스에 있는 작은 로컬 버퍼에서 데이터를 읽어오거나, 디바이스와 관련된 작업을 수행합니다.</br>4.인터럽트 처리가 끝나면, CPU는 이전에 중단했던 작업으로 복귀합니다. |

|소프트웨어 인터럽트|프로세스의 시스템콜 호출 또는 프로세스 오류(트랩)로 발생|1.프로세스가 시스템콜을 호출하거나 오류가 발생하면, 해당 이벤트가 인터럽트로 인식됩니다.</br>2.CPU는 커널 모드로 전환되어, 시스템콜이나 예외 상황에 대응하는 핸들러를 실행합니다. </br> 3.처리 후에는 다시 사용자 모드로 전환하여 프로세스의 실행을 계속합니다.|

### DMA 컨트롤러

I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치

- CPU에만 너무 많은 인터럽트 요청이 들어오기 떄문에 CPU 부하를 막아 주며 PCU의 일을 부단하는 보조 일꾼
- 하나의 작업을 CPU와 DMA 컨트롤러가 동시에 하는 것을 방지합니다.

### 메모리

메모리는 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치를 말하며, 보통 RAM을 일컬어 메모리라고도 합니다. CPU는 계산을 담당하고, 메모리는 기억을 담당합니다.

### 타이머

몇 초 안에는 작업이 끝나야 한다는 것을 정하고 특정 프로그램에 시간 제한을 다는 역할을 함. 시간이 많이 걸리는 프로그램이 작동할 때 제한을 걸기 위해 존재

### 디바이스 컨트롤러

디바이스 컨트롤러는 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU를 말하고 옆에 붙어 있는 로컬 버퍼는 가가 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리를 뜻합니다

# 메모리

CPU는 메모리에 올라와 있는 프로그램의 명령어들을 실행한다

## 메모리 계층

| 상태        | 이름                            |
| ----------- | ------------------------------- |
| 속도↑ 용량↓ | 레지스터                        |
|             | 캐시(L1, L2 캐시)               |
|             | 메모리(RAM)/주기억장치          |
| 속도↓ 용량↑ | 저장장치(HDD, SSD)/보조기억장치 |

- 레지스터: CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 적다
- 캐시 : L1, L2 캐시를 지칭, 휘발성, 속도 빠름, 기억 용량이 적다
- 주기억장치 : RAM을 가르킨다. 휘발성, 속도 보통, 기억 용량 보통
- 보조기억장치 : HDD. SSD를 일컬으며 비휘발성, 속도 낮음, 기억 용량이 많다

### RAM

- 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장, 필요 시마다 CPU에 빠르게 전달하는 역할 담당
- 계층 위로 올라갈수록 가격은 비싸지는데 용량은 작아지고 속도는 빨라지는 특징이 있음 (경제성과 캐시 때문에 이러한 계층을 두어 관리)

### 캐시

| 캐시는 **자주 사용되는 데이터를 미리 복사해 놓는 임시 저장소**로, 장치 간의 속도 차이로 인한 병목 현상을 줄이기 위해 사용되는 메모리 계층입니다.

#### 주요 목적

- **속도 차이 해소:**  
  CPU, 주기억장치(메인 메모리), 보조기억장치 등 서로 다른 속도를 가진 장치들 사이에서 데이터 전송 시 발생하는 병목 현상을 완화합니다.

- **데이터 접근 시간 단축:**  
  자주 사용되는 데이터를 캐시에 저장해 두면, 메인 메모리나 보조기억장치에 비해 훨씬 빠르게 데이터에 접근할 수 있어 전반적인 시스템 성능이 향상됩니다.

#### 장점

- **빠른 데이터 접근:**  
  캐시는 메모리 접근 시간이 오래 걸리는 문제를 해결하여, CPU가 필요한 데이터를 신속하게 얻을 수 있도록 돕습니다.

- **시간 절약:**  
  이미 계산되거나 읽어온 데이터를 캐시에 저장해 두면, 동일한 데이터를 다시 계산하거나 읽어오는 데 걸리는 시간을 절약할 수 있습니다.

- **속도 차이 보완:**  
  메모리와 CPU 사이의 속도 차이를 줄이기 위해, 캐시는 CPU와 메모리 사이 혹은 메모리와 보조기억장치 사이에 위치한 중간 계층으로 작동합니다.

#### 캐싱 계층의 예시

예를 들어, **캐시 메모리와 보조기억장치 사이에 위치한 주기억장치**는 보조기억장치의 캐싱 계층 역할을 합니다.

- **보조기억장치(예: HDD, SSD):**  
  상대적으로 느린 저장 장치이지만, 대용량 데이터를 저장할 수 있습니다.
- **주기억장치(메인 메모리):**  
  보조기억장치보다 빠른 속도로 데이터를 읽고 쓸 수 있어, 자주 사용되는 데이터를 임시로 저장하여 캐시 역할을 수행합니다.
- **캐시 메모리:**  
  CPU와 가장 가까운 위치에 있어, 가장 빠른 속도로 데이터를 제공함으로써 전체 시스템의 성능을 극대화합니다.

이처럼 각 계층이 속도와 용량의 차이를 보완하며, 효율적인 데이터 처리를 위해 캐시를 포함한 여러 메모리 계층이 함께 작동합니다.

##### 지역성의 원리

- 캐시 계층을 두는 것 말고 캐시를 직접 설정할 시에는 **자주 사용하는 데이터를 기반**으로 설정해야한다.
- 자주 사용하는 데이터에 대한 근거가 되는 것은 **지역성**이다
- 지역성은 시간 지역성과 공간 지역성으로 나뉨

**시간 지역성** : 최근 사용한 데이터에 다시 접근하려는 특성을 말합니다.
**공간 지역성** : 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

### 캐시히트와 캐시미스

|      | 캐시히트                                                                | 캐시미스                                                                |
| ---- | ----------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| 의미 | 원하는 데이터를 찾았다 (데이터를 제어장치를 거쳐 가져옴)                | 캐시에 해당 데이터가 없어 주 메모리로 가서 데이터를 찾아왔다            |
| 특징 | **빠르다**, 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠름 | 메모리에서 가져오기에 시스템 버스를 기반으로 작동하기 때문에 **느리다** |

#### 캐시매핑

- 캐시가 히트되기 위해 매핑하는 방법
- CPU의 레지스터와 주 메모리 간에 데이터를 주고받을 때를 기반으로 설명
- 레지스터는 주 메모리에 비하면 굉장히 작고 주 메모리는 굉장히 크기 때문에 작은 레지스터가 캐시 계층으로써 역할을 잘 해주려면 이 매핑을 어떻게 하느냐가 중요합니다.

| 이름           | 설명                                                                                             | 장점          | 단점                                  |
| -------------- | ------------------------------------------------------------------------------------------------ | ------------- | ------------------------------------- |
| 직접 매핑      | 메인 메모리의 각 블록이 미리 정해진 하나의 캐시 라인에만 저장될 수 있도록 매핑하는 방식          | 처리가 빠름   | 충돌 발생이 잦음                      |
| 연관 매핑      | 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑하는 방식                                   | 충돌이 적다   | 모든 블록을 탐색해야 해서 속도가 느림 |
| 집합 연관 매핑 | 직접 매핑과 연관 매핑을 헙쳐둔 방식</br>순서를 일치시키지만 집합을 둬서 저장하며 블록화 되어있어 | 검색이 효율적 |                                       |

#### 웹 브라우저의 캐시

- 소프트웨어적인 대표적인 캐시로는 웹 브라우저의 작은 저장고 쿠키, 로컬 스토리지, 세션 스토리지가 있음
- 사용자의 커스텀한 정보나 인증 모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰이며 오리진에 종속됩니다.

##### 쿠키

- 만료기한이 있는 키-값 저장소입니다
- same site 옵션을 strict로 설정하지 않을 경우 다른 도메인에서 요청했을 때 자동 전송
- 4kb까지 데이터를 저장할 수 있고 만료기한을 정할 수 있습니다
- 쿠키를 설정할 때는 document.cookie로 쿠키를 볼 수 없게 httponly 옵션을 거는 것이 중요
- 클라이언트 또는 서버에서 만료기한 등을 정할 수 있는데 보통 서버에서 만료기한을 정합니다.

##### 로컬 스토리지

- 만료기한이 없는 키-값 저장소입니다.
- 5mb까지 저장할 수 있으며 웹 브라우저를 닫아도 유지됩니다.
- HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없으며 클라이언트에서만 수정 가능합니다.

##### 세션 스토리지

- 만료기한이 없는 키-값 저장소입니다.
- 탭 단위로 세션 스토리지를 생성하며, 탭을 닫을 때 해당 데이터기 삭제됩니다.
- 5Mb까지 저장이 가능하며 HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없습니다.
- 클라이언트에서만 수정 가능합니다.

#### 데이터베이스의 캐싱 계층

데이터베이스 시스템을 구축할 때도 메인 데이터베이스 위에 redis 데이터 베이스 계층을 캐싱 계층으로 둬서 성능을 향상시키기도 합니다.

## 메모리 관리

운영체제의 대표적인 할 일 중 하나가 메모리 관리, 컴퓨터 내의 한정된 메모리를 극한으로 활용해야한다.

### 가상메모리

| 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 사용하는 메모리를 크게 보이게 만드는 것을 말한다.

- 가상 주소: 가상적으로 주어진 주소
- 실제 주소: 실제 메모리상에 있는 주소

- 가상 주소는 메모리 관리 장치에 의해 실제 주소로 변환되며, (실제 주소를 의식할 필요 없이 프로그램 구축 가능)

가상메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 ‘페이지 테이블’로 관리됩니다. 이때 속도 향상을 위해 TLB를 씁니다.

TLB: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시이다. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층이다.

#### 스와핑

만약 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생합니다. 이때 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것을 스와핑이라고 합니다. 이를 통해 마치 페이지 폴트가 일어나지 않는 것처럼 만듭니다.

#### 페이지 폴트

프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우에 발생합니다. 페이지 폴트와 그로 인한 스와핑은 다음 과정으로 이루어집니다.

1. 어떤 명령어가 유효한 가상 주소에 접근했으나 해당 페이지가 만약 없다면 트랩이 발생되어 운영체제에 알리게 됩니다.
2. 운영체제는 실제 디스크로부터 사용하지 않은 프레임을 찾습니다.
3. 해당 프레임을 실제 메모리에 가져와서 페이지 교체 알고리즘을 기반으로 특정 페이지와 교체합니다(이때 스와핑 발생)
4. 페이지 테이블을 갱신시킨 후 해당 명령어를 다시 시작

- 페이지: 가상 메모리를 사용하는 최소 크기 단위
- 프레임: 실제 메모리를 사용하는 최소 크기 단위

### 스레싱

메모리의 페이지 폴트율이 높은 것을 의미하며, 이는 컴퓨터의 심각한 성능 저하를 초래합니다.

스레싱은 메모리에 너무 맣은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 발생하는 것이죠. 페이지 폴트가 일어나면 CPU 이용률이 낮아집니다. CPU 이용률이 낮아지게 되면 운영체제는 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 올리게 됩니다. 이와 같은 악순환이 반복되며 스레싱이 일어나게 됩니다.

이를 해결하기 위한 방법으로는 메모리를 늘리거나, HDD를 사용한다면 HDD를 SSD로 바꾸는 방법이 있습니다. 이외에 운영체제에서 이를 해결할 수 있는 방법은 작업 세트와 PFF가 있다.

#### 작업 세트

프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것입니다. 미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있고 스와핑 또한 줄일 수 있다

#### PFF

페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법
만약 상한선에 도달한다면 프레임을 늘리고 하한선에 도달한다면 프레임을 줄이는 것

### 메모리 할당

시작 메모리 위치, 메모리의 할당 크기를 기반으로 할단하는데, 연속 할당과 불연속 할당으로 나뉩니다.

| 이름           | 방식                                                       | 설명                                                                                                                        |
| -------------- | ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| 연속 할당      | 메모리에 연속적으로 공간 할당                              | 메모리를 미리 나누어 관리하는 고정 분할 방식, 매 시점 프로그램의 크기에 맞게 메모리를 분할하여 사용하는 가변 분할 방식 존재 |
| 고정 분할 방식 | 메모리를 미리 나누어 관리하는 방식                         | 메모리가 미리 나뉘어 있기 때문에 융통성이 없습니다. 또한, 내부 단편화가 발생                                                |
| 가변 분할 방식 | 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용 | 내부 단편화는 발생하지 않고 외부 단편화는 발생할 수 있습니다(최초적합, 최적적합, 최악적합)                                  |

#### 가변 분할 방식 종류

| 최초적합 | 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당합니다 |
| -------- | -------------------------------------------------------- |
| 최적적합 | 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당     |
| 최악적합 | 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당합니다. |

내부 단편화: 메모리르 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
외부 단편화: 메모리르 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상
홀: 할당할 수 있는 비어 있는 메모리 공간

#### 불연속 할당

메모리를 연속적으로 할당하지 않는 불연속 할당은 현대 운영체제가 쓰는 방법으로 불연속 할당인 페이징 기법이 있습니다. 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 것.

#### 페이징

동일한 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당. 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해집니다.

#### 세그멘테이션

페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식입니다. 프로세스를 이루는 메모리는 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 이루어지는데, 코드와 데이터로 나누거나 코드 내의 작은 함수를 세그먼트로 놓고 나눌 수 있습니다. 이는 공유와 보안 측면에서 장점을 가지지만 홀 크기가 균일하지 않은 단점이 있습니다.

#### 페이지드 세그멘테이션

페이지드 세그멘테이션은 프로그램을 의미 단위인 세그먼트로 나눠 공유나 보안 측면에 강점을 두고 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것을 말합니다.

### 페이지 교체 알고리즘

메모리는 한정되어 있기 떄문에 스와핑이 많이 일어납니다. 스와핑은 많이 일어나지 않도록 설계되어야 하며 이는 페이지 교체 알고리즘을 기반으로 스와핑이 일어납니다

#### 오프라인 알고리즘

먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이며, 가장 좋은 방법
그러나 미래에 사용되는 프로세스를 알 수 없기에 사용할 수 없는 알고리즘, 떄문에 다른 알고리즘과의 성능 비교에 대한 상한기준을 제공

#### FIFO

가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법을 의미

#### LRU

참조가 가장 오래된 페이지를 바꾼다. 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야하는 문제점이 있습니다.
LRU를 구현하기 위해 두 가지 자료구조를 사용
해시 테이블은 이중 연결 리스트에서 빠르게 찾을 수 있도록 쓰고, 이중 연결 리스트는 한정된 메모리를 나타냅니다.

#### NUR

LRU에서 발전한 NUR 알고리즘
일명 clock 알고리즘이라고 하며 먼저 0과 1을 가진 비트를 둡니다. 1은 최근에 참조되었고 0은 참조되지 않음을 의미합니다. 시계 방향으로 돌면서 0을 찾고 0을 찾는 순간 해당 프로세스를 교체하고, 해당 부분을 1로 바꾸는 알고리즘

#### LFU

가장 참조 횟수가 작은 페이지를 교체합니다. 즉, 많이 사용되지 않은 것을 교체하는 것

# 프로세스와 스레드

- 프로세스는 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케줄링의 대상이 되는 작업이라는 용어와 같이 사용
- 스레드는 프로세스 내 작업의 흐름을 지칭
- 프로그램이 메모리에 올라가면 프로세스가 되는 인스턴스화가 일어나고, 이후 운영체제의 CPU 스케줄러에 따하 CPU가 프로세스를 실행

## 프로세스와 컴파일 과정

프로세스는 프로그램이 메모리에 올라가 인스턴스화된 것을 말한다.
프로그램은 구글 크롬 프로그램과 같은 실행 파일이며, 이를 두 번 클릭하면 구글 크롬 프로세스로 변환되는 것
프로그램을 만드는 과정은 만드는 언어마다 다를 수 있으며 컴파일 언어인 C 언어 기반의 프로그램을 기준으로 설명하면 컴파일러가 컴파일 과정을 통해 컴퓨터가 이해할 수 있는 기계어로 번역하여 실행할 수 있는 파일을 만들게 된다.

### 전처리

소스 코드의 주석을 제거하고 #include 등 헤더 파일을 병합하여 매크로로 치환합니다.

### 컴파일러

오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환

### 어셈블러

목적 코드로 변환됩니다. 확장자는 운영체제마다 다른데 리눅스는 .o이다.

### 링커

프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만듭니다. 실행 파일의 확장자는 .exe .out이라는 확장자를 갖습니다.

**정적 라이브러리와 동적 라이브러리**
라이브러리는 정적 라이브러리와 동적 라이브러리로 나뉩니다.
정적 라이브러리는 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식으로 라이브러리를 쓰는 방법. 시스템 환경 등 외부 의존도가 낮은 장점이 있지만 코드 중복 등 메모리 효욜성이 떨어지는 단점이 있다
동적 라이브러리는 프로그램 실핼 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법
메모리 효율성에서의 장점을 지니지만 외부 의존도가 높아진다는 단점이 있다

## 프로세스의 상태

### 생성 상태

프로세스가 생성된 상태를 의미라며 fork() 또는 exec() 함수를 통해 생성합니다. 이때 PDB가 할당됩니다.

### fork()

부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수입니다. 주소 공간만 복사할 뿐이지 부모 프로세스의 비동기 작업 등을 상속하지는 않는다.

### exec()

새롭게 프로제스를 생성하는 함수

### 대기 상태

메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태입니다

### 대기 중단 상태

메모리 부족으로 일시 중단된 상태

### 실행 상태

CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태를 의미한다. 이를 CPU burst가 일어났다고 표현

### 중단 상태

어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태입니다. I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생하기도 합니다.

### 일시 중단 상태

대기 중단과 유사합니다. 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태입니다.

### 종료 상태

메모리와 CPU 소유권을 모두 놓고 가는 상태를 말합니다. 종료는 자연스럽게 종료되는 것도 있지만 부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료로 종료되는 것도 있습니다. 자식 프로세스에 할당된 자원의 한계치를 넘어서거나 부모 프로세스가 종료되거나 사용자가 process, kill 등 여러 명령어로 프로세스를 종료할 때 발생합니다

## 프로세스의 메모리 구조

운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당합니다.
위에서부터 스택, 힙, 데이터 영역, 코드 영역으로 나눠집니다. 스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당됩니다.

### 스택과 힙

스택과 힙은 동적 할당이 되며, 동적 할당은 런타임 단계에서 메모리를 할당받는 것을 말합니다. 스택은 지역 변수, 매개변수, 실행되는 함수에 의해 늘어들거나 줄어드는 메모리 영역입니다. 함수가 호출될 때마다 호출될 떄의 환경 등 특정 정보가 스택에 계속해서 저장됩니다.
또한, 재귀 함수가 호출된다고 했을 때 새로운 스택 프레임이 매번 사용되기 때문에 함수내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않습니다.
힙은 동적으로 할당되는 변수들을 담습니다. malloc(), free() 함수를 통해 관리할 수 있으며 동적으로 관리되는 자료 구조의 경우 힙 영역을 사용합니다. 예를 들어 vector는 내부적으로 힙 영역을 사용

### 데이터 영역과 코드 영역

정적 할당되는 영역. 정적 할당은 컴파일 단계에서 메모리를 할당하는 것을 말합니다. 데이터 영역은 BSS segment와 Data segment, code/text segment로 나뉘어서 저장됩니다.
BSS segment는 전역 변수 또는 static, const로 선언되어 있고 0으로 초기화 또는 초기화가 어떠한 값으로도 되어 있지 않은 변수들이 이 메모리 영역에 할당되며 Data segment는 전역 변수 또는 static, consr로 선언되어 있고 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당됩니다.
code segmetn는 프로그램의 코드가 들어간다.

## PCB

운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말한다.

프로세스 제어 블록이라고도 합니다.

프로세스가 생성되면 운영체제는 해당 PDB를 생성합니다.

프로그램이 실행되면 프로세스가 생성되고 프로세스 주소 값들에 앞서 설명한 스택, 힙 등의 구조를 기반으로 메모리가 할당됩니다. 그리고 이 프로세스의 메타데이터들이 PCB에 저장되어 관리됩니다. 이는 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리됩니다.

메타데이터 : 데이터에 관한 구조화된 데이터이지 데이터를 설명하는 작은 데이터, 대량의 정보 가운데에서 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일정한 규칙에 따라 콘텐츠에 대해 부여되는 데이터이다.

### PCB의 구조

PCB는 프로세스 스케줄링 상태, 프로세스 ID 등의 다음과 같은 정보로 이루어져 있습니다.

- 프로세스 스케쥴링 상태: 준비, 일시중단 등 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
- 프로세스 ID: 프로세스 ID, 해당 프로세스의 자식 프로세스 ID
- 프로세스 권한: 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
- 프로그램 카운터: 프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터
- CPU 레지스터: 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
- CPU 스케줄링 정보: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
- 계정 정보: 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
- I/O 상태 정보: 프로세스에 할당된 I/O 디바이스 목록

### 컨텍스트 스위칭

PCB를 기반으로 프로세스의 상태를 저장하고 로드시키는 과정을 말합니다. 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생합니다. 컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이지만 어떠한 시점에서 실행되고 있는 프로세스는 단 한 개이며, 많은 프로세스가 동시에 구동되는 것처럼 보이는 것은 다른 프로세스와의 컨텍스트 스위칭이 아무 빠른 속도로 실행되기 때문입니다.

(현대 컴퓨터는 멀티코어 CPu를 가지기 때문에 한 시점에 한 개의 프로그램은 틀린 설명)

**비용: 캐시미스**
컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변황이 생기므로 캐시클리어 과정을 겪게 되고 이 때문에 캐시미스가 발생한다

**스레드에서의 컨텍스트 스위칭**
스레드에서도 일어남 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 스레드 컨텍스트 스위칭의 경우 비용이 더 적고 시간도 더 적게 걸린다.

## 멀티프로세싱

여러 개의 프로세스, 멀티프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것을 말합니다.

이를 통해 하나 이상의 일을 병렬로 처리할 수 있으며 측정 프로세스의 메모리, 프로세스 중 일부에 문제가 발생되더라도 다른 프로세스를 이용해서 처리할 수 있으므로 신뢰성이 높은 강점이 있다. 참고로 멀티프로세싱은 하드웨어 관점에서 봤을 때 여러 개의 프로세서로 작업을 처리하는 것을 의미하기도 한다.

### 웹 브라우저

멀티프로세스 구조를 가지고 있으며 다음과 같다

- 브라우저 프로세스: 주소 표시줄, 북마크 막대, 뒤로 가기 버튼, 앞으로 가기 버튼 등을 담담하며 네트워크 요청이나 파일 접근 같은 권한을 담당
- 렌더러 프로세스: 웹 사이트가 보이는 부분의 모든 것을 제어
- 플러그인 프로세스: 웹 사이트에서 사용하는 플러그인을 제어
- GPU 프로세스: GPU 이용해서 화면을 그리는 부분을 제어합니다.

### IPC

프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 매커니즘을 뜻한다

클라이언트와 서버를 예로 들 수 있는데, 클라이언트는 데이터를 요청하고 서버는 클라이언트 요청에 응답하는 것도 IPC의 예이다

IPC의 종류로는 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐가 있습니다. 이들은 모두 메모리가 완전히 공유되는 스레드보다는 속도가 떨어진다.

#### 공유 메모리

여러 프로세스에 동일한 메모리 블록에 대한 접근 권한이 부여되어 프로세스가 서로 통신할 수 있도록 공유 메모리를 생성해서 통신하는 것을 말합니다.

기본적으로는 각 프로세스의 메모리를 다른 프로세스가 접근할 수 없지만 공유 메모리를 통해 여러 프로세스가 하나의 ㅔ메모리를 공유할 수 있습니다. IPC 방식 중 어떠한 매개체를 통해 데이터를 주고박는 것이 아닌 메모리 자체를 공유하기 때문에 불필요한 데이터 복사의 오버헤드가 발생하지 않아 가장 빠르며 같은 메모리 여역을 여러 프로세스가 공유하기 때문에 동기화가 필요합니다.

참고로 하드웨어 관점에서 공유 메모리는 CPU가 접근할 수 있는 큰 랜덤 접근 메모리인 RAM을 가리키도 합니다.

#### 파일

디스크에 저장된 데이터 또는 파일 서버에서 제공한 데이터를 말합니다. 이를 기반으로 프로세스 간 통신을 합니다.

#### 소켓

동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송한느 데이터를 의미하며 TCP, UDP가 있습니다.

#### 익명 파이프

프로세스 간에 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고받으며, 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동하는 방식을 말합니다.

이는 부모, 자식 프로세스 간에만 사용할 수 있으며 다른 네트워크상에서는 사용이 불가능합니다.

#### 명명된 파이프

파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 명명된 단방향 또는 양방향 파이프를 말합니다. 클라이언트/서버 통신을 위한 별도의 파이프를 제공하며, 여러 파이프를 동시에 사용할 수 있습니다. 컴퓨터의 프로세스끼리 또는 다른 네트워크상의 컴퓨터와도 통신을 할 수 있습니다.

보통 서버용 파이프와 클라이언트용 파이프로 구분해서 작동하며 하나의 인스턴스를 열거나 여러 개의 인스턴스를 기반으로 통신합니다.

#### 메시지 큐

메시지를 큐 데이터 구조 형태로 관리하는 것을 의미합니다. 커널의 전역변수 형태 등 커널에서 전역적으로 관리되며 다른 IPC 방식에 비해서 사용 방법이 매우 직관적이고 간단하며 다른 코드의 수정 없이 단지 몇 줄의 코드를 추가시켜 간단하게 메시지 큐에 접근 할 수 있다는 장점이 있습니다.

공유 메모리를 통해 IPC를 구현할 때 쓰기 및 읽기 빈도가 높으면 동기화 때문에 기능을 구현하는 것이 매우 복잡해지는데, 이때 대안으로 메시지 큐를 사용하기도 합니다.

## 스레드와 멀티스레딩

### 스레드

프로세스의 실행 가능한 가장 단위. 프로세스는 여러 스레드를 가질 수 있습니다.

코드, 데이터, 스택, 힙을 각각 생성하는 프로세스와는 달리 스레드는 코드, 데이터, 힙은 스레드끼리 서로 공유합니다.

그 외의 영역은 각각 생성됩니다.

### 멀티스레딩

프로세스 내 작업을 여러 개의 스레드, 멀티스레드오 처리하는 기법이며 스레드끼리 서로 자원을 공유하기 때문에 효율성이 높습니다. 예를 들어 웹 요청을 처리할 때 새 프로세스를 생성하는 대신 스레드를 사용하는 웹 서버의 경우 훨씬 적은 리소스를 소비하며, 한 스레드가 중단되어도 다른 스레드는 실행 상태일 수 있기 때문에 중단되지 않은 빠른 처리가 가능합니다. 또한, 동시성에도 큰 장점이 있습니다, 하지만 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수 있는 단점이 있습니다.

동시성 : 서로 독립적인 작업들을 작은 단위로 나누고 동시에 실행되는 것처럼 보여주는 것

멀티스레드의 예로는 웹 브라우저의 렌더러 프로세스를 예로 들 수 있다.

이 프로세스 내에는 메인 스레드, 워커 스레드, 컴포지터 스레드, 레스터 스레드가 존재

## 공유 자원과 임계 영역

### 공유 자원

시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등을 의미합니다. 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁 상태라고 합니다. 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태인 것이죠

### 임계 영역

둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서등의 이유로 결과가 달라지는 코드 영역을 말합니다. 임계 영역을 해결하기 위한 방법은 크게 뮤텍스, 세마포어, 모니터 세 가지가 있으며, 이 방법 모두 상호 배제, 한정 대기, 융통성이란 조건을 만족합니다. 이 방법에 토대가 되는 매커니즘은 잠금입니다.

상호 배제 : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다

한정 대시 : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다.

융통성 : 만약 어떠한 프로세스도 임계 영역을 사용하지 않는다면 임계 영역 외부의 어떠한 프로세스도 들어갈 수 있으며 이 때 프로세스끼리 서로 방해하지 않는다.

#### 뮤텍스

프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고 사용한 후에는 unlock()을 통해 잠금 해제하는 객체입니다. 잠금이 설정되면 다른 프로세스나 스레드는 잠긴 코드 영역에 접근할 수 없고 해제는 그 반대. 또한 뮤텍스는 잠금 또는 잠금 해제라는 상태만을 가집니다.

#### 세마포어

일반화된 뮤텍스입니다. 간단한 정수 겂과 두 가지 함수 wait 치 signal로 공유 자원에 대한 접근을 처리합니다.

wait()는 자신의 차례가 올 때까지 기다리는 함수이며, signal()은 다음 프로세스로 순서를 넘겨주는 함수입니다.

프로세스나 스레드가 공유 자원에 접근하면 세마포어에서 wait() 작업을 수행하고 프로세스나 스레드가 공유 자원을 해제하면 세마포어에서 signal()작업을 수행합니다. 세마포어에는 조건 변수가 없고 프로세스나 스레드가 세마포어 값을 수정할 때 다른 프로세스나 스레드는 동시에 세마포어 값을 수정할 수 없습니다.

##### 바이너리 세마포어

0과 1의 두 가지 값만 가질 수 있는 세마포어입니다. 구현의 유사성으로 인해 뮤텍스는 바이너리 세마포어라고 할 수 있지만 엄밀히 말하면 뮤텍스는 잠금을 기반으로 상호배제가 일어나는 잠금 매커니즘니고, 세마포어는 신호를 기반으로 상호 배제가 있어나느 신호 메커니즘입니다. 여기서 신호 매커니즘은 휴대폰에서 노래를 듣다가 친구로부터 전화가 오면 노래가 중지돠고 통화 처리 작업에 관한 인

##### 카운틴 세마포어

여러 개의 값을 가질 수 있는 세마포어이며, 여러 자원에 대한 접근을 제어하는 데 사용됩니다.

#### 모니터

둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공합니다.

모니터는 모니터큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리합니다.

모니터는 세마포어보다 구현하기 쉬우며 모니터에서 상호 배제는 자동인 반면에, 세마포어에서는 상호 배제를 명시적ㅇ로 구현해야 하는 차이점이 있습니다.

## 교착 상태

두 개이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말합니다.

### 교착 상태의 원인

- 상호 배제: 한 프로세스가 자원을 독접하고 있으며 다른 프로세스들은 접근이 불가능
- 점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
- 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없습니다.
- 환형 대기: 프로세스 A는 프로세스 B의 자원을 요구하고 , 프로세스 B는 프로세스 자원을 요구하는 등 서로가 서로의 자우너을 요구하는 상황을 말합니다

### 교착 상태의 해결 방법

1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계
2. 교착 상태 가능성이 없을 때만 자우너 할당되며, 프로세스 당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 은해우언 알고리즘
3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지우기

은행원 알고리즘: 총 자원의 양과 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘

# CPU 스케줄링 알고리즘

CPU 스케줄링 알고리즘에 따라 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당

프로그램이 실행될 때는 CPU 스케줄링 알고리즘이 어떤 프로그램에 CPU 소유권을 줄것인지 결정합니다.
알고리즘은 CPU 이용률은 높게, 주어진 시간에 많은 일을 하게, 준비 큐에 있는 프로세스는 적게, 응답 시간은 짧게 설정하는 것을 목표로 합니다

## 비선점형 방식

프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로세스를 중지하지 않습니다. 따라 컨텍스트 스위칭으로 인한 부하가 적습니다.

### FCFS

가장 먼저 온 것을 가장 먼저 처리하는 알고리즘입니다. 길게 수행되는 프로세스 때문에 준비 큐에서 오래 기대리는 현상이 발생하는 단점이 있습니다.

### SJF

실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘입니다.

긴 시간을 가진 프로세스가 실행되지 않는 현상이 일어나며 평균 대기 시간이 가장 짧습니다. 하지만 실제로는 실행 시간을 알 수 없기 때문에 과거의 실행했던 시간을 토대로 추측해서 사용합니다.

### 우선순위

기존 SJF 스케줄링의 경우 긴 시간을 가진 프로세스가 실행되지 않는 현상이 있었습니다

우선 순위는 이 단점을 오래된 작업일수록 우선순위를 높이는 방법을 사용해 보완한 알고리즘입니다. 참고로 우선순위는 앞서 설명한 SJF와 우선순위를 말하는 것 뿐만 아니라 FCFS를 활용하여 만들기도 하며 선점형, 비선점형적인 우선순위 스케줄링 알고리즘을 말하기도 합니다.

## 선점형 방식

현대 운영체제가 쓰는 방식으로 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식을 말합니다.

### 라우드 로빈

현대 컴퓨터가 쓰는 선점형 알고리즘 스케줄링 방법으로 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘입니다.

예를 들어 q만큼의 할당 시간이 부여되었고 N개의 프로세스가 운영된다고 하면 (N-1)\*q 시간이 지나면 가지 차례가 오게 됩니다, 할당 시간이 너무 크면 FCFS가 되고 짧으면 컨텍스트 스위칭이 잦아져서 오버헤드, 즉 비용이 커집니다. 일반적으로 전체 작업 시간은 길어지지만 평균 응답 시간은 짧아진다는 특징이 있습니다.

또한, 이 알고리즘은 로드밸런서에서 트래픽 분산 알고리즘으로도 쓰입니다.

### SRF

중간에 실행 시간이 더 짧은 작업이 들어와도 기존 짧은 작업을 모두 수행하고 그 다음 짧은 작업을 이어나가는데, SRF는 중산에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘입니다.

### 다단계 큐

다단계 큐는 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라우드 로빈이나 FCFS등 다른 스케줄링 알고리즘을 적용한 것을 말합니다. 큐 간의 프로세스 이동이 안 되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징이 있습니다.
